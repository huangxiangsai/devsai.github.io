<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SAI的技术博客</title>
  
  <subtitle>最可怕的敌人，就是没有坚强的信念。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.devsai.com/"/>
  <updated>2018-04-10T12:47:57.713Z</updated>
  <id>http://www.devsai.com/</id>
  
  <author>
    <name>SAI</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node-Sass安装失败引发的思考</title>
    <link href="http://www.devsai.com/2018/04/07/node-sass-trouble/"/>
    <id>http://www.devsai.com/2018/04/07/node-sass-trouble/</id>
    <published>2018-04-06T16:00:00.000Z</published>
    <updated>2018-04-10T12:47:57.713Z</updated>
    
    <content type="html"><![CDATA[<p>在mac OS或liunx系统下，有时候在安装node-sass时会出现，<code>Permissions Errors</code></p><p>可能出现的情况是这样:</p><p><img src="/images/2018/node-sass-reinstall-error.png" alt="loop reinstall"></p><hr><p><strong>阅读后你将得到什么</strong></p><blockquote><ol><li>你将成功的解决node-sass安装不了苦恼（相同或类似的问题）</li><li>不仅仅是node-sass，其他模块如此类问题，同样可以解决</li><li>你将获得处理此类问题的，多种解决方案</li><li>你将了解到出现此类问题的原因，以及如何避免此类问题</li></ol></blockquote><h2 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h2><p>找到输出信息里的关键词<code>user &quot;root&quot; does not have permission to access the dev dir</code></p><p>貌似是权限问题，但有时候是<code>root</code>用户了，为什么会有权限问题？</p><p>解决问题的方案有下面几种：</p><h2 id="方案一-添加参数（–unsafe-perm）"><a href="#方案一-添加参数（–unsafe-perm）" class="headerlink" title="方案一 添加参数（–unsafe-perm）"></a>方案一 添加参数（–unsafe-perm）</h2><p>在安装<code>node-sass</code>时，使用参数<code>--unsafe-perm</code></p><p>例如：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --unsafe-perm <span class="keyword">node</span><span class="title">-sass</span></span><br></pre></td></tr></table></figure><p>解析：</p><p><code>--unsafe-perm</code> 在root下默认值为false,其他的默认值为true</p><p>设置为true,在run package script时会切换UID/GID<br>明确设置为false,在非root用户下安装会失败</p><h2 id="方案二-添加参数-–user-root"><a href="#方案二-添加参数-–user-root" class="headerlink" title="方案二 添加参数(–user=root)"></a>方案二 添加参数(–user=root)</h2><p>在安装<code>node-sass</code>时，使用参数<code>--user=root</code></p><p>例如：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="attr">user=</span>root <span class="keyword">node</span><span class="title">-sass</span></span><br></pre></td></tr></table></figure><p>该参数指定了再执行脚本时使用的账号(UID),默认是<code>nobody</code>      </p><h2 id="方案四-修改现有node的权限"><a href="#方案四-修改现有node的权限" class="headerlink" title="方案四 修改现有node的权限"></a>方案四 修改现有node的权限</h2><p>如果你是直接使用了已经编译后的node版本</p><p><img src="../images/2018/node-download.png" alt=""></p><p>那么你解压之后的目录权限可能是这样的</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxr-x  <span class="number">7</span> dev  dev  <span class="number">4.0</span>K <span class="number">3</span>月  <span class="number">24</span> <span class="number">11</span>:<span class="number">25</span> <span class="keyword">node</span><span class="title">-v8</span>.<span class="number">10.0</span>-linux-x64</span><br></pre></td></tr></table></figure><p>也可能是这样的</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxr-x  <span class="number">7</span> <span class="number">500</span>  <span class="number">500</span>  <span class="number">4.0</span>K <span class="number">3</span>月  <span class="number">24</span> <span class="number">11</span>:<span class="number">25</span> <span class="keyword">node</span><span class="title">-v8</span>.<span class="number">10.0</span>-linux-x64</span><br></pre></td></tr></table></figure><p>这里就需要修改node目录的权限为<code>root</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown root:root <span class="keyword">node</span><span class="title">-v8</span>.<span class="number">10.0</span>-linux-x64</span><br></pre></td></tr></table></figure><h2 id="方案四-重新安装node-推荐使用nvm"><a href="#方案四-重新安装node-推荐使用nvm" class="headerlink" title="方案四 重新安装node(推荐使用nvm)"></a>方案四 重新安装node(推荐使用nvm)</h2><p>nvm是个node版本管理工具，可以方便的下载安装node，并且可以方便的切换node版本</p><p>这是直接贴上nvm地址，如何安装<a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">看文档</a></p><h2 id="方案五-npm提供的解决方案（How-to-Prevent-Permissions-Errors）"><a href="#方案五-npm提供的解决方案（How-to-Prevent-Permissions-Errors）" class="headerlink" title="方案五 npm提供的解决方案（How to Prevent Permissions Errors）"></a>方案五 npm提供的解决方案（How to Prevent Permissions Errors）</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建.npm-global目录</span></span><br><span class="line">mkdir ~/.<span class="built_in">npm</span>-<span class="built_in">global</span></span><br><span class="line"><span class="comment">## 设置</span></span><br><span class="line"><span class="built_in">npm</span> config set prefix <span class="string">'~/.npm-global'</span></span><br><span class="line"><span class="keyword">export</span> PATH=~/.<span class="built_in">npm</span>-<span class="built_in">global</span>/bin:$PATH</span><br><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure><p>通过上述方法的其中一种，就可以解决问题。</p><p></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.npmjs.com/misc/config#unsafe-perm" target="_blank" rel="noopener">unsafe-perm</a></li><li><a href="https://docs.npmjs.com/getting-started/fixing-npm-permissions" target="_blank" rel="noopener">fixing-npm-permissions</a></li><li><a href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b" target="_blank" rel="noopener">npx</a></li></ul>]]></content>
    
    <summary type="html">
    
      在mac OS或liunx系统下，有时候在安装node-sass时会出现，Permissions Errors 的错误提示，那么这种情况下，我们要怎么处理呢。
    
    </summary>
    
    
      <category term="node-sass" scheme="http://www.devsai.com/tags/node-sass/"/>
    
  </entry>
  
  <entry>
    <title>了解Webp</title>
    <link href="http://www.devsai.com/2018/02/01/2018-webp/"/>
    <id>http://www.devsai.com/2018/02/01/2018-webp/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-02-01T12:22:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webp"><a href="#webp" class="headerlink" title="webp"></a>webp</h1><p><strong>webp</strong>是google开发的一种新图片格式，例如现有的图片格式（jpg,gif,png等等）。</p><p>既然已经有了这么多的图片格式了，那为什么还会出这么个新的图片格式呢。</p><blockquote><p>  A new image format for the Web </p></blockquote><p>专门为web而生的一种新图片格式。同质量的图片，拥有更小的体积。</p><p>据google官方所说</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li></ul><p>同时webp具备现有图片格式的一些特点，比如：png支持透明，gif动态图，webp也同样支持。</p><h2 id="webp格式图片怎么获得-其他格式转webp格式"><a href="#webp格式图片怎么获得-其他格式转webp格式" class="headerlink" title="webp格式图片怎么获得(其他格式转webp格式)"></a>webp格式图片怎么获得(其他格式转webp格式)</h2><p>Google提供了命令行工具用于将图片转换为webp，在WIN,MAC,Liunx各个平台下都可使用。官方的<a href="https://developers.google.com/speed/webp/download" target="_blank" rel="noopener">下载地址</a>（需翻墙访问）</p><p>Google提供的工具如下：</p><blockquote><p>  cwebp – WebP encoder tool</p><p>  dwebp – WebP decoder tool</p><p>  vwebp – WebP file viewer</p><p>  webpmux – WebP muxing tool</p><p>  gif2webp – Tool for converting GIF images to WebP</p></blockquote><p>Mac OS X系统下， 可以使用下面的命令快速安装：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>webp</span><br></pre></td></tr></table></figure><p>安装完成后，便可使用上述的<code>cwebp</code>,<code>dwebp</code>这两命令。 </p><ul><li><code>cwebp</code> 压缩 可以将PNG,JPEG,TIFF图片格式转成webp</li><li><code>dwebp</code> 解压 可以将webp格式解压成PNG</li></ul><p>命令具体用法不多说，自行参考官网文档。</p><p>我们常用的图片格式除了PNG,JPEG外，动图gif也使用比较多。webp想转gif的用到官方提供的<code>gif2webp</code>。</p><p>当然我们也可以选择第三方的一些转换图片工具，比如：<a href="https://www.xnview.com/en/xnconvert/" target="_blank" rel="noopener">XNConvert</a></p><h2 id="使用webp做web前端图片优化"><a href="#使用webp做web前端图片优化" class="headerlink" title="使用webp做web前端图片优化"></a>使用webp做web前端图片优化</h2><p><img src="https://user-images.githubusercontent.com/7732840/35482861-d472cf26-0475-11e8-9a04-3e9e9cea5164.png" alt=""></p><p>目前桌面浏览器Chrome和Opera支持webp，android上的原生浏览器，Chrome,UC也支持。</p><p>safari和FireFox也正在尝试支持webp。</p><p>那么还有这么多的浏览器不支持。是否有必要使用webp做优化呢。 答案是肯定的，以桌面端为例，Chorme浏览器以占了超50%的使用率。</p><p>就喜马拉雅FM web官网Chrome的用户就占了64%。</p><p>通过webp的优化，能够加快图片的加载速度，并且还能节省带宽。</p><p>那么如果我们想给自己的网站使用webp做优化，需要怎么做呢。</p><ul><li>(PageSpeed for Apache 或 PageSpeed for Nginx）做自动转换成webp</li><li>可以添加额外的应用逻辑来检测客户端，检查客户端支持的格式，并提供最合适的图片格式。</li></ul><h3 id="PageSpeed"><a href="#PageSpeed" class="headerlink" title="PageSpeed"></a>PageSpeed</h3><p>PageSpeed nginx模块为例</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -<span class="keyword">f</span> -L -sS http<span class="variable">s:</span>//ngxpagespeed.<span class="keyword">com</span>/install) \</span><br><span class="line">    --nginx-<span class="keyword">version</span> <span class="number">1.12</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><p>开启模块<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http模块下配置如下:</span></span><br><span class="line">pagespeed <span class="keyword">on</span>;</span><br><span class="line">pagespeed FileCachePath <span class="string">"/var/cache/ngx_pagespeed/"</span>;</span><br></pre></td></tr></table></figure></p><p>添加过滤项，即图片转换规则<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server模块下配置如下：</span></span><br><span class="line">pagespeed EnableFilters convert_jpeg_to_webp,convert_gif_to_png, convert_png_to_jpeg;</span><br></pre></td></tr></table></figure></p><p>了解更多<a href="https://www.modpagespeed.com/doc/" target="_blank" rel="noopener">PageSpeed</a></p><h3 id="javascript判断浏览器是否支持webp"><a href="#javascript判断浏览器是否支持webp" class="headerlink" title="javascript判断浏览器是否支持webp"></a>javascript判断浏览器是否支持webp</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check_webp_feature:</span></span><br><span class="line"><span class="comment">//   'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.</span></span><br><span class="line"><span class="comment">//   'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_webp_feature</span><span class="params">(feature, callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> kTestImages = &#123;</span><br><span class="line">        lossy: <span class="string">"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"</span>,</span><br><span class="line">        lossless: <span class="string">"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA=="</span>,</span><br><span class="line">        alpha: <span class="string">"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA=="</span>,</span><br><span class="line">        animation: <span class="string">"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = (img.width &gt; <span class="number">0</span>) &amp;&amp; (img.height &gt; <span class="number">0</span>);</span><br><span class="line">        callback(feature, result);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        callback(feature, <span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = <span class="string">"data:image/webp;base64,"</span> + kTestImages[feature];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nodejs端转webp"><a href="#nodejs端转webp" class="headerlink" title="nodejs端转webp"></a>nodejs端转webp</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> webp-converter</span><br></pre></td></tr></table></figure><p>使用<code>webp-converter</code>转图片格式为webp,模块具体使用<a href="https://www.npmjs.com/package/webp-converter" target="_blank" rel="noopener">查看</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后我们来看一组对比测试，到底使用了webp与不使用相差了多少。（测试数据以及功能来自京东 凹凸实验室）</p><p>点击这里进入<a href="http://labs.qiang.it/wen/webp/test.html" target="_blank" rel="noopener">测试页面</a>（非WIFI访问请注意，打开页面将花费您2M左右流量）</p><p>测试结果如下： </p><p><img src="https://img.aotu.io/Fng21Plg7-00b3HKFe48nLIgP_fn" alt=""></p><p>那么是不是已经有点心动了，快去尝试使用webp给你的网站做图片优化吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/WebP" target="_blank" rel="noopener">webp wiki</a></li><li><a href="https://aotu.io/notes/2016/06/23/explore-something-of-webp/index.html" target="_blank" rel="noopener">京东凹凸实验室对webp的介绍</a></li><li><a href="https://developers.google.com/speed/webp/" target="_blank" rel="noopener">google webp</a></li><li><a href="https://developers.google.com/speed/webp/faq#how_can_i_detect_browser_support_for_webp" target="_blank" rel="noopener">browser_support_webp</a></li><li><a href="https://www.modpagespeed.com/doc/filter-image-optimize" target="_blank" rel="noopener">PageSpeed_Image_Optimize</a></li></ul>]]></content>
    
    <summary type="html">
    
      webp是google开发的一种新图片格式，例如现有的图片格式（jpg,gif,png等等）。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.devsai.com/tags/JavaScript/"/>
    
      <category term="webp" scheme="http://www.devsai.com/tags/webp/"/>
    
  </entry>
  
  <entry>
    <title>React-Native开发前的见面礼--误入依赖坑</title>
    <link href="http://www.devsai.com/2017/01/06/rn-depinstall/"/>
    <id>http://www.devsai.com/2017/01/06/rn-depinstall/</id>
    <published>2017-01-05T16:00:00.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>对前端开发的同学来说，react native开发肯定是让人兴奋，用javaScript来开发app应用，想想就激动。</p><p>正好，有这么个机会，要用rn开发个功能，代码已由同事开发了部分。</p><p>所以，我从git上更新最新的代码后就想把代码跑起来，而想代码跑起来要做的第一件事便是安装依赖。</p><p>谁会想到，就装个依赖而已，而我却掉进了这坑里，这个千万分之一的概率都不知道有没有的坑。</p><h2 id="装个依赖而已"><a href="#装个依赖而已" class="headerlink" title="装个依赖而已"></a>装个依赖而已</h2><p>我想，很多的同学，都是用<code>npm</code>做依赖包管理的吧。</p><p>可<code>npm</code>的访问速度实在太慢了，慢得感觉不到有数据过来，怎么可以忍受我们 宝贵的时间就这么白白的被浪费了。</p><p>于是乎，我们万能的淘宝出了个淘宝镜像，通过这镜像去安装依赖包，这速度，真是飞一般的感觉。</p><p>大厂就是大厂，对大厂就有一种莫名的信任感，据说用的人还挺多。</p><p>随便贴下怎么用着镜像吧</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install cnpm -g --registry=https:<span class="regexp">//</span>registry.<span class="built_in">npm</span>.taobao.org</span><br></pre></td></tr></table></figure><p>然后就可以使用<code>cnpm</code>安装各种依赖包了，用法跟使用<code>npm</code>一样。</p><p>聪明的我，也是这么做的。</p><h2 id="掉坑里了"><a href="#掉坑里了" class="headerlink" title="掉坑里了"></a>掉坑里了</h2><p>那么，问题来了，我通过<code>cnpm i</code>用了眨了下眼睛的时间安装完了依赖后。</p><p>直接执行了如下命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native <span class="keyword">run</span><span class="bash">-ios</span></span><br></pre></td></tr></table></figure><p>本来的反应应该是，经过一系列的编译，启动模拟器，同时启动本地服务用来热更新代码</p><p>可就在启动本地服务时却报了如下的错，本地服务直接终止了。</p><p><img src="/images/2017/rn/dep-error.png" alt="image"></p><p>而查了下<code>src</code>中的javaScript代码，并没有使用到<code>on</code>啊。</p><p>顿时感觉不好了，一头雾水，这是啥情况呢， 之后就不断的做各种的猜测与尝试</p><p>是不是node版本不对呢，问题之前开发的同事用的node版本，发现不同，立马装上同版本的node，可还是不行</p><p>是不是xcode的版本问题呢，因为执行<code>react-native run-ios</code>会调用xcode进行build，报着试试看的心态，升级了xcode，发现还是不对</p><p>是不是依赖没装好呢，于是清了<code>./node_modules</code>目录，再安装了一遍，结果依然不行。</p><p>在网上找了一大圈也没找到个原因，这TM是什么情况。。。</p><p>正当要绝望之时，突然想到之前装的react native的官方demo, 进入目录运行<code>react-native run-ios</code>，神奇般的没有任何报错的起来了，我的天呐~</p><p>这时，我已经可以很明确的知道，肯定不是node的问题，也不是xcode的问题，那么是不是依赖的问题呢，</p><p>于是删了官方例子中<code>./node_modules</code>的文件，用<code>cnpm i</code>又安装一遍，再次执行<code>react-native run-ios</code>，居然也不行了，报了同样的错。</p><p>好吧， 到这里，已经非常的明显了，就是安装的依赖包引起的。 </p><p>于是向同事讨要了其他的镜像地址<code>http://r.cnpmjs.org</code>，我再使用如下命令在项目中尝试安装了下依赖包</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="selector-tag">i</span>  --registry http:<span class="comment">//r.cnpmjs.org/</span></span><br></pre></td></tr></table></figure><p>果不其然，再次执行<code>react-native run-ios</code>，很顺利的跑起来了。</p><p>原来都是<code>cnpm</code>惹的祸，妄我这么的信任你。</p><p>当然了，也是不说通过<code>cnpm</code>安装的依赖就一定会报错了，我只是中了这千万分之一的概率。</p><h2 id="还没完"><a href="#还没完" class="headerlink" title="还没完"></a>还没完</h2><p>写到这应该是好结束了，因为问题已经解决了。</p><p>可是，到底是加载了哪个依赖包出的问题呢，为什么用<code>cnpm</code>安装就会有问题呢，我们还是不知道。</p><p>贯彻我一向的刨根问底的精神，我又经过了我多次的尝试，发现问题就出在<code>react-native</code>这个最主要的包上。这就尴尬了，总不能不装这个包吧。</p><p>那么，<code>react-native</code>包为什么就不行呢，通过查看以<code>cnpm</code>和<code>npm i  --registry http://r.cnpmjs.org/</code>两种方式生成的<code>node-modules</code>中的文件发现，<code>cnpm</code>生成的目录都是个<code>symlink</code>符号链接，真正的文件夹是平级目录下的隐藏文件夹，以版本号开头命名；而通过另一种方式生成的就是正常的文件夹了。</p><p>这<code>cnpm</code>到底干了啥呢，阅读了下在github上的说明,里面有这么一段：</p><p><img src="/images/2017/rn/cnpm.png" alt="image"></p><p>原来上面说的符号链接就是这么来的，而且还告诉我们可以切换成用<code>npm</code>来安装，于是，再次删除<code>./node_modules</code>，执行<code>cnpm i --by=npm</code> , 发现<code>node_modules</code>中不再是符号链接了，再执行<code>react-native run-ios</code>后，程序顺利的执行了，当然，当改成了<code>npm</code>方式安装，就体验不到<code>cnpm</code>带给你的飞一般的安装速度了。</p><p>所以，出错的原因应该是使用了<a href="https://github.com/cnpm/npminstall" target="_blank" rel="noopener">npminstall</a>来安装依赖，通过上面一刨，可以知道，<code>cnpm</code>还是可以用的。只要改下它使用的默认安装方法。 </p><p>对于<code>npminstall</code>安装为什么会导致依赖出错，就不再做深入的研究了。感兴趣的同学可以继续研究。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>写下此篇，望能帮助到同样中了这千万分之一概率的同学们，及时发现问题所在。</p>]]></content>
    
    <summary type="html">
    
      react-native开发，入坑第一篇，介绍了什么依赖包遇到了问题，及如何去解决它的，主要是由cnpm引起的
    
    </summary>
    
    
      <category term="javaScript" scheme="http://www.devsai.com/tags/javaScript/"/>
    
      <category term="react-native" scheme="http://www.devsai.com/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>mac下mongoDB的安装</title>
    <link href="http://www.devsai.com/2017/01/03/mongodb-install/"/>
    <id>http://www.devsai.com/2017/01/03/mongodb-install/</id>
    <published>2017-01-02T16:00:00.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h2><p>官方介绍</p><blockquote><p>   MongoDB（来自于英文单词“Humongous”，中文含义为“庞大”）是可以应用于各种规模的企业、各个行业以及各类应用程序的开源数据库。作为一个适用于敏捷开发的数据库，MongoDB的数据模式可以随着应用程序的发展而灵活地更新。与此同时，它也为开发人员 提供了传统数据库的功能：二级索引，完整的查询系统以及严格一致性等等。 MongoDB能够使企业更加具有敏捷性和可扩展性，各种规模的企业都可以通过使用MongoDB来创建新的应用，提高与客户之间的工作效率，加快产品上市时间，以及降低企业成本。</p></blockquote><p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p><p>官方提供了多种方法安装<a href="https://docs.mongodb.com/manual/administration/install-community/" target="_blank" rel="noopener">mongoDB</a></p><p>这里拿OS X为例，记录下我的安装过程：</p><p>安装的mongoDB版本为<code>3.4.1</code></p><p>由于使用<code>Homebrew</code>依赖管理器有问题，果断放弃这种方式的安装。</p><p>采用手动安装模式，即源码安装</p><p>步骤如下：</p><ul><li>下载源码到本地</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https:<span class="regexp">//</span>fastdl.mongodb.org<span class="regexp">/osx/m</span>ongodb-osx-ssl-x86_64-<span class="number">3.4</span>.<span class="number">1</span>.tgz</span><br></pre></td></tr></table></figure><ul><li>解压文件</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span> <span class="selector-tag">mongodb-osx-ssl-x86_64-3</span><span class="selector-class">.4</span><span class="selector-class">.1</span><span class="selector-class">.tgz</span></span><br></pre></td></tr></table></figure><ul><li>将解压后的文件内容，拷贝到需要的指定目录(例如：~/mongodb)</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 需先创建目录</span><br><span class="line">mkdir ~<span class="string">/mongodb</span></span><br><span class="line"></span><br><span class="line">cp -R -n mongodb-osx-ssl-x86_64-3.4.1/   ~<span class="string">/mongodb</span></span><br></pre></td></tr></table></figure><p>其实这步骤可以省略，只要在想要存放的目录下去下载源码，并解压，需要的话再修改下解压后的目录名</p><p>还需注意，新创建的目录需要有用户权限。</p><ul><li>配置环境变量,这步骤也可省略，只要你不嫌执行命令麻烦</li></ul><p>在~/.bashrc文件中添加以下内容：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="string">"<span class="variable">$PATH</span>:&lt;your-mongodb-directory&gt;"</span></span><br></pre></td></tr></table></figure><p>这是的<code>&lt;your-mongodb-directory&gt;</code>就是上面的<code>~/mongodb</code></p><ul><li>通过命令启动mongodb</li></ul><p>在执行命令前，还需添加，存放数据的目录</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mkdir</span> /<span class="class"><span class="keyword">data</span>/db    # 如果不是管理员身份操作，需使用 sudo</span></span><br><span class="line"><span class="title">chown</span> -<span class="type">R</span> &lt;当前的用户&gt; /<span class="class"><span class="keyword">data</span></span></span><br></pre></td></tr></table></figure><p>然后执行启动命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mongod</span></span><br></pre></td></tr></table></figure><p>执行命令后会看到它启动的端口,在浏览器中输入<code>127.0.0.1:27017</code>，会看到以下一段话，告诉你正在尝试连接mongodb数据库</p><blockquote><p>   It looks like you are trying to access MongoDB over HTTP on the native driver port.</p></blockquote><p>至此最简单的mongodb服务已经起来了。</p><p>当然你也可以做一些其他的设置比如：端口（默认为<code>27017</code>），存放文件的目录(默认为<code>//data/db</code>),可以通过对命令<code>mongod</code>后添加参数的方式来实现</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod <span class="params">--port</span> 10086  <span class="params">--dbpath</span> ~<span class="string">/mongodb/data/db</span></span><br></pre></td></tr></table></figure><p>相关的配置还有很多，你也可以把这些配置写配置文件里，只需在执行命令时指定配置文件即可。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f ~<span class="regexp">/mongodb/m</span>ongodb.conf</span><br></pre></td></tr></table></figure><p><code>mongodb.conf</code>文件内容为： </p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">net:</span></span><br><span class="line"><span class="symbol">port:</span> <span class="number">10086</span></span><br><span class="line"></span><br><span class="line">storage</span><br><span class="line"><span class="symbol">dbPath:</span> ~<span class="meta-keyword">/mongodb/</span>data/db</span><br></pre></td></tr></table></figure><p>更详细的配置请查看<a href="https://docs.mongodb.com/manual/reference/configuration-options/" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mongodb&quot;&gt;&lt;a href=&quot;#mongodb&quot; class=&quot;headerlink&quot; title=&quot;mongodb&quot;&gt;&lt;/a&gt;mongodb&lt;/h2&gt;&lt;p&gt;官方介绍&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;   MongoDB（来自于英文单词“Humong
      
    
    </summary>
    
    
      <category term="mongoDB" scheme="http://www.devsai.com/tags/mongoDB/"/>
    
      <category term="记录" scheme="http://www.devsai.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的跨域资源共享(CORS)</title>
    <link href="http://www.devsai.com/2016/12/15/little-know-cors/"/>
    <id>http://www.devsai.com/2016/12/15/little-know-cors/</id>
    <published>2016-12-14T16:00:00.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>有没有一看到讲跨域资源共享的就不想再看的了，网上的跨域资源共享的博文，三天两头的就出一篇。</p><p>既然你已经进来看了，还请你稍稍忍耐下，继续往下看，或许你会发现和之前看到的有不一样的收获。</p><p>（亲，东西保您好，不好不要钱哦~~）</p><p>其实，之前看过我写的文章的同学可能知道，我写过一篇关于《跨域及跨域资源共享》（没有看过的同学，可以从这<a href="http://www.devsai.com/2016/11/24/talk-CORS/" target="_blank">进去</a>）。比较全面的介绍了跨域的多种解决方案，以及说明了跨域资源共享.</p><p>你们会不会想：那既然已经写过了，为什么又写一篇？ 是不是博主已经没啥东西可写了。</p><p>别急，接下来，让我跟你们慢慢道来。</p><h1 id="你们所知道的"><a href="#你们所知道的" class="headerlink" title="你们所知道的"></a>你们所知道的</h1><p>看过之前写的《跨域及跨域资源共享》或看过多篇CORS文章的同学可以选择性的跳过这一小段了。</p><p>就像你们看到过的相关的文章，讲跨域资源共享，一般讲其原理时，必定要讲到跨域资源共享的请求有两种（也有很多没有讲到）：</p><blockquote><p>   简单请求 （Simple Request）<br>   预检测请求 (Preflight Request)</p></blockquote><p>然后就会进一步的讲到，什么时候发只发简单请求，又什么时候会在发真实的请求前，先发预检测请求，普遍的都是这么说的（包括我之前写的也是）</p><p>以下几种情况时都满足时是简单请求</p><p><strong>request header 是简单的请求头</strong></p><blockquote><p>   Accept<br>   Accept-Language<br>   Content-Language<br>   Last-Event-ID<br>   Content-Type<br>  等等非自定义的请求头</p></blockquote><p><strong>request method 是下面的请求类型</strong></p><blockquote><p>   HEAD<br>   GET<br>   POST</p></blockquote><p><strong>Content-Type 只限三个值</strong></p><blockquote><p>   application/x-www-form-urlencoded、multipart/form-data、text/plain</p></blockquote><p>如果不满足以上条件的都会先发送预检测请求，即为<code>OPTIONS</code>请求类型的请求</p><p>几乎都是这么说的，差别只是描述方式不同，比例下面的别人写的：</p><p><img src="/images/2016/cors/preflight01.png" alt=""></p><p>什么？ 不信， 那你随便搜索几篇相关的文章看看。</p><h1 id="那么，这有什么问题"><a href="#那么，这有什么问题" class="headerlink" title="那么，这有什么问题"></a>那么，这有什么问题</h1><p>先来做个例子吧。</p><p>假设要实现带进度条的上传功能，接口不是同域上的，服务端已经给配置了支持跨域资源共享的响应头，那我们直接用XmlHttpRequest就可以了</p><p>javaScript代码大概如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XmlHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.upload.onprogress = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'POST'</span>,<span class="string">'http://127.0.0.1/upload'</span>);</span><br><span class="line"><span class="keyword">var</span> fd = <span class="keyword">new</span> FormData();</span><br><span class="line">fd.append(<span class="string">'file'</span>,file);</span><br><span class="line">xhr.send(fd);</span><br></pre></td></tr></table></figure><p>然后上传文件并查看下请求</p><p><img src="/images/2016/cors/preflight02.png" alt=""></p><p>What? 为什么会有两个请求啊。 是不是它不满足简单请求的要求（已不记得简单请求的同学往上再看看）</p><p>那么，我们来看看该真实请求的请求头</p><p><img src="/images/2016/cors/preflight03.png" alt=""></p><p>简单请求要求：</p><table><thead><tr><th style="text-align:center">要求点</th><th style="text-align:center">实际内容</th><th style="text-align:center">是否满足</th></tr></thead><tbody><tr><td style="text-align:center">请求方式</td><td style="text-align:center">POST</td><td style="text-align:center">满足</td></tr><tr><td style="text-align:center">请求头</td><td style="text-align:center">都是非自定义的请求头</td><td style="text-align:center">满足</td></tr><tr><td style="text-align:center">Content-Type</td><td style="text-align:center">multipart/form-data</td><td style="text-align:center">满足</td></tr></tbody></table><p>不是都满足了吗？那为什么，会有两个请求，为什么在发送真实请求前还发了<code>OPTIONS</code>方式的请求。</p><p>为什么！！！整个人感觉都不好了！！！</p><h1 id="变个魔术"><a href="#变个魔术" class="headerlink" title="变个魔术"></a>变个魔术</h1><p>把上面的javaScript代码改动下:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="type">XmlHttpRequest</span>();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span></span>() &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'POST'</span>,<span class="string">'http://127.0.0.1/upload'</span>);</span><br><span class="line"><span class="keyword">var</span> fd = <span class="keyword">new</span> <span class="type">FormData</span>();</span><br><span class="line">fd.append(<span class="string">'file'</span>,file);</span><br><span class="line">xhr.send(fd);</span><br></pre></td></tr></table></figure><p>去掉了<code>xhr.upload.onprogress</code>，上传后再来看下请求及请求头：</p><p><img src="/images/2016/cors/preflight05.png" alt=""></p><p><img src="/images/2016/cors/preflight04.png" alt=""></p><p>只有一个请求，请求头内容还都一样。 (这到底是怎么回事…有种再也不相信爱情的赶觉了！！！)</p><p>看到这里的同学，有木有觉得博主在坑你们，放了两张相同的请求头截图就想糊弄。</p><p>俗话说得好，不试不知道，一试吓一跳，要不，你们也亲自试试，一试便知真假。</p><p>再次双手奉上<a href="https://github.com/huangxiangsai/web-upload-demo" target="_blank">demo</a>（喜欢的顺便点个赞哦~）。</p><h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>从上面的两小段JS看出，只是去除了上传的进度信息事件。也就是说加了进度事件就多发了个预检测请求。</p><p>那么，还有没有其他的事件了？添加其他的事件会不会也会发送预检测请求呢？</p><p>事件有<code>onerror</code>,<code>onloadstart</code>等等。经过博主的测试，上述答案是肯定的，添加其他事件后，确实也会发生预检测请求。</p><p>追求真理的同学们，在博主的demo里改改试试吧。</p><p>现在已经知道了问题的所在，由上传相关事件导致了跨域请求多发了预检测请求，说好的简单请求(Simple Request)呢~</p><p>博主抱着对问题刨根问底的精神，再次查看<a href="http://www.w3.org/TR/cors/#resource-requests" target="_blank">cors</a>相关文档，找到了如下的内容：</p><blockquote><ul><li><p>If the following conditions are true, follow the simple cross-origin request algorithm:</p><ul><li><p>The request method is a simple method and the force preflight flag is unset.</p></li><li><p>Each of the author request headers is a simple header or author request headers is empty.</p></li></ul></li></ul></blockquote><p>通过这段，我们知道，原来除了我们所知道的简单请求的几大特征外，还提到了<code>force preflight flag</code>，这是什么鬼？</p><p>难道是因为设置了它？ 那么什么时候设置了<code>force preflight flag</code>?</p><p>上面我们知道了因为上传事件导致了发送预检测请求，会不会是上传监听事件的时候给设置了<code>force preflight flag</code>，<br>然后在<a href="http://www.w3.org/TR/2011/WD-XMLHttpRequest2-20110816/" target="_blank">XmlHttpRequest level 2</a> 中的找到了相关的内容，以证实我的猜测是正确的。</p><p>有下面几段内容：</p><blockquote><p>   force preflight flag<br>       The upload events flag.</p></blockquote><p>从这段可以知道，<code>force preflight flag</code>与<code>upload events flag</code>是对应的,看到这里就知道了，只要<code>upload events flag</code>被设置<code>true</code></p><p>那么就等于<code>force preflight flag</code>被设置了<code>true</code>，这时，不管请求的类型的是不是<em>simple method</em>，也不管请求头是不是<em>simple header</em>，都会先发送预检测请求。</p><p>接下来，我们再来看看<code>upload events flag</code>会在什么情况下被设置呢？</p><blockquote><p>   If the asynchronous flag is true and one or more event listeners are registered on the XMLHttpRequestUpload object set the upload events flag to true. Otherwise, set the upload events flag to false.</p></blockquote><p>原来，当<code>asynchronous flag</code>为<code>true</code>并且XMLHttpRequestUpload(即示例中的xhr.upload)的一个或多个事件被监听的时候，<code>upload listener flag</code>就会被设置了。</p><p>这也正如之前测试的，当加了<code>xhr.upload.onprogress</code>后，出现了预检测请求。</p><p>到这里总算水落石出了。</p><p>这里还需要说明的一点是，<code>the asynchronous flag</code>就是<code>xhr.open()</code>的第三个参数，当未设置第三参数时，默认为异步，也就是<code>the asynchronous flag</code>为<code>true</code></p><p>如果第三个参数设置为<code>false</code>，那么即使有上传的监听事件也不会发送预检测请求（Preflight Reuqest）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以后还会不会理直气壮的在别人面前说，只要是满足几大条件（是非自定义的请求头，是<code>GET</code>or<code>POST</code>or<code>HEAD</code>,或<code>Content-Type</code>是那三种值的）就是简单请求 ，就不会发生预检测请求。</p><p>通过本文可知，并非满足这几大条件就一定是简单请求的，<br>应该要加个前置条件，是否是在上传请求中跨域，是否是异步的，是否监听了上传事件。</p><p>看到这，可能你想说，写这么多有啥用，对实际开发有帮助吗？或许没什么实际的帮助吧，又或许你也不会碰到吧。</p><p>但，最起码当你碰到的时候，你看到了两个请求，再看了下代码，你已经心里就有数了，知道这是怎么一回事了。</p><p>一直认为，做技术的对碰到的问题要知其然，更要知其所以然。</p>]]></content>
    
    <summary type="html">
    
      对网上现有的跨域资源共享中，讲到的简单请求部分，进行更为深入分析。
    
    </summary>
    
    
      <category term="CORS" scheme="http://www.devsai.com/tags/CORS/"/>
    
      <category term="跨域资源共享" scheme="http://www.devsai.com/tags/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Backbone系列篇之Backbone.Events源码解析</title>
    <link href="http://www.devsai.com/2016/12/10/backbone-events/"/>
    <id>http://www.devsai.com/2016/12/10/backbone-events/</id>
    <published>2016-12-09T16:00:00.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直想着读读源码，但一直没有找到目标，一些流行的框架，大多代码量不少。</p><p>就像是面对着高耸如云的山峰，抬头望去，就已经没了攀登的勇气。</p><p>俗话说的好，凡事得一步一个脚印，一口吃不出个胖子。</p><p>大框架搞不定，可以短小精悍的类库下手。</p><p>打BOSS前必定要杀掉无数的小怪。</p><p>而，backbone就是个非常好的选择，加上它的注释也就2000行左右。</p><p>也在网上看到一些对Backbone源码的解析，但或多或少的有以下几个情况：</p><ul><li>一些Backbone解析，只做了部分就停更了</li><li>Backbone解析的，据现在已有年代，解析的源码与现在的有略微的出入</li><li>对源码的解析，多少带有阅读者的想法</li></ul><p>最后一点，也是最重要的一点，并不是阅读者的想法不对，<br>而是想，如果自己去阅读，或许能得到不同的想法。</p><p>而且对于阅读源码的来说，他从源码中获得的收获，一定是要比写出来的多。</p><p>我建议大家去看别人对一些源码的解析，更建议自己也去试着读读源码。<br>这样，自己对源码更深入理解的同时，还可以对别人做的分析，进行更深层次的探讨。</p><h1 id="Backbone-Events-事件机制"><a href="#Backbone-Events-事件机制" class="headerlink" title="Backbone.Events 事件机制"></a>Backbone.Events 事件机制</h1><p>本文中会出现部分的源码，点击这里<a href="https://github.com/jashkenas/backbone" target="_blank">查看</a>完整源码</p><p>Events 相关代码有200多行</p><p>对外定义的方法有:</p><p><img src="/images/2016/backbone/backbone-events-api.png" alt=""></p><p>代码开始，就先定义了Backbone.Events，这是为什么呢</p><p>因为Backbone的其他部分对象都是继承了Events，也是就说,Backbone.Model,Backbone.Collection,Backbone.View,Backbone.Router</p><p>都可以使用Events的属性。</p><p>Backbone.Events也可以使用在任何的对象上，就像这样:<code>var o=_.extend({},Backbone.Events);</code></p><p>然后<code>o</code>对象，就可以随心所欲的做到订阅/发布了。</p><p>上述的API方法可以分三部分：</p><p><img src="/images/2016/backbone/events-02.png" alt=""></p><ul><li>绑定事件 <strong>on,listenTo,once,bind</strong> </li></ul><p>首先，<code>on</code>和<code>bind</code>是完全一样的，只是取了个别名。方便大家的使用习惯。</p><p><code>listenTo</code>官方说明是对<code>on</code>控制反转。如何反转，后面具体说明。</p><p><code>once</code>就很好理解了，注册的事件只执行一次,完了自动解绑。这也就是为什么下面的解绑方法中没有对其解绑的动作了。（一次性筷子，用完就扔，不需要洗）</p><ul><li>解绑事件 <strong>off,stopListening,unbind</strong> </li></ul><p>同样的<code>off</code>与<code>unbind</code>除了方法名不同外，作用完全一样。</p><p><code>stopListening</code>也是用来解绑的，但它比较厉害了，对调用对象解绑解的彻彻底底。</p><ul><li>触发事件 <strong>trigger</strong>  </li></ul><p>通过此方法可以触发单个或同时触发多个事件。<code>trigger(eventname)</code>， 第一个参数为事件名，其他的参数为传给事件执行函数的参数。</p><h2 id="listenTo-on的控制反转"><a href="#listenTo-on的控制反转" class="headerlink" title="listenTo(on的控制反转)"></a>listenTo(<code>on</code>的控制反转)</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span>.listenTo(other, <span class="keyword">event</span>, callback)</span><br></pre></td></tr></table></figure><p>让 object 监听 另一个（other）对象上的一个特定事件。不使用other.on(event, callback, object)，而使用这种形式的优点是：listenTo允许 object来跟踪这个特定事件，<br>并且以后可以一次性全部移除它们。callback总是在object上下文环境中被调用。</p><p>这里有个概念叫<code>Inversion of Control(IoC控制反转)</code><br>这是种主从关系的转变，一种是A直接控制B，另一种用控制器（<code>listenTo</code>方法）间接的让A控制B。</p><p>通过<code>listenTo</code>把原本<code>other</code>主导绑定监听事件，变成了由<code>object</code>主导绑定监听事件了。</p><h2 id="与on比较"><a href="#与on比较" class="headerlink" title="与on比较"></a>与<code>on</code>比较</h2><p>从功能上来说，on,listenTo是一样的。</p><p>来看个例子：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> changeHandler = <span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">&#123;&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">model</span>.<span class="title">on</span><span class="params">(<span class="string">'change:name'</span>,changeHandler,view)</span>;</span></span><br></pre></td></tr></table></figure><p>或者可以这样</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.listenTo(<span class="keyword">model</span>,<span class="string">'change:name'</span>,changeHandler);</span><br></pre></td></tr></table></figure><p>两种方式的作用是一样的，当model的name发生改变时，调用view中的方法。</p><p>可当view中不止有一个model时呢</p><p>功能上来讲，还是无差别，但如果想要当离开页面时view需要销毁，view中model绑定的事件也需要注销时，看看两种绑定方式，对面这问题时会怎么办</p><p><strong>on</strong>的解绑</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">view</span> = &#123;</span><br><span class="line">    changeName :function(name)&#123;</span><br><span class="line">       <span class="comment">//doing something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">model.<span class="keyword">on</span>('change:name',<span class="keyword">view</span>.changeName,<span class="keyword">view</span>);</span><br><span class="line">model2.<span class="keyword">on</span>('change:name',<span class="keyword">view</span>.changeName,<span class="keyword">view</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//view离开时，model如何解绑</span></span><br><span class="line">model.off('change:name',<span class="keyword">view</span>.changeName,<span class="keyword">view</span>);</span><br><span class="line">model2.off('change:name',<span class="keyword">view</span>.changeName,<span class="keyword">view</span>);</span><br></pre></td></tr></table></figure><p>有多个model的话，需要进行多次的解绑操作。</p><p>再来看看<strong>listenTo</strong>的解绑</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">view</span>.listenTo(model,'change:name',<span class="keyword">view</span>.changeName)<span class="comment">;</span></span><br><span class="line"><span class="keyword">view</span>.listenTo(model2,'change:name',<span class="keyword">view</span>.changeName)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解绑</span></span><br><span class="line"><span class="keyword">view</span>.stopListening()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>并不需要做更多的操作就能把view相关的监听事件给解绑。</p><p>而通过查看<code>stopListening</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Events.stopListening = function(obj, name, callback) &#123;</span><br><span class="line">  <span class="keyword">var</span> listeningTo = <span class="keyword">this</span>._listeningTo;</span><br><span class="line">  <span class="keyword">if</span> (!listeningTo) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ids = obj ? [obj._listenId] : _.keys(listeningTo);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ids.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> listening = listeningTo[ids[i]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If listening doesn't exist, this object is not currently</span></span><br><span class="line">    <span class="comment">// listening to obj. Break out early.</span></span><br><span class="line">    <span class="keyword">if</span> (!listening) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    listening.obj.off(name, callback, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内部执行了多次的<code>.off(name, callback, this)</code>，相当于内部给做了用<code>on</code>绑定后的解绑操作。</p><h2 id="深入了解listenTo"><a href="#深入了解listenTo" class="headerlink" title="深入了解listenTo"></a>深入了解listenTo</h2><p>先举个例子,执行<strong>view.listenTo(model,’change’,changeHandler)</strong>， 执行过程看下面注释：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Events.listenTo = function(obj, name, callback) &#123;</span><br><span class="line">  <span class="comment">//  obj = model</span></span><br><span class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// obj._listenId 不存在，执行 id = (obj._listenId = _.uniqueId('l'))  == 'l1'</span></span><br><span class="line">  <span class="keyword">var</span> id = obj._listenId || (obj._listenId = _.uniqueId(<span class="string">'l'</span>));  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// this._listeningTo 不存在，执行 listeningTo = (this._listeningTo = &#123;&#125;)</span></span><br><span class="line">  <span class="keyword">var</span> listeningTo = <span class="keyword">this</span>._listeningTo || (<span class="keyword">this</span>._listeningTo = &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// listening = this._listeningTo[obj._listenId]  : undefined ==  (&#123;&#125;)['l1']</span></span><br><span class="line">  <span class="keyword">var</span> listening = listeningTo[id];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// true 执行条件语句</span></span><br><span class="line">  <span class="keyword">if</span> (!listening) &#123;</span><br><span class="line">    <span class="comment">// this._listenId == undefined , thisid = (this._listenId = _.uniqueId('l')) == 'l2'</span></span><br><span class="line">    <span class="keyword">var</span> thisId = <span class="keyword">this</span>._listenId || (<span class="keyword">this</span>._listenId = _.uniqueId(<span class="string">'l'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this._listeningTo[obj._listenId]  = &#123;....&#125;</span></span><br><span class="line">    listening = listeningTo[id] = &#123;obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: <span class="number">0</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  internalOn(obj, name, callback, <span class="keyword">this</span>, listening);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码执行中，会调用内部函数<code>onApi</code>（在<code>internalOn</code>内调用），执行<code>handlers.push({callback: callback, context: context, ctx: context || ctx, listening: listening});</code></p><p>执行完后：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">model._listenId = <span class="string">'l1'</span></span><br><span class="line"><span class="keyword">view</span>._listenId = <span class="string">'l2'</span></span><br><span class="line"><span class="keyword">view</span>._listeningTo = &#123;<span class="string">'l1'</span> : &#123;obj:model,objId : <span class="string">'l1'</span>,id : <span class="string">'l2'</span>,listeningTo: <span class="keyword">view</span>._listeningTo,<span class="built_in">count</span> : <span class="number">0</span>&#125;&#125;</span><br><span class="line">model._listeners = &#123;<span class="string">'l2'</span> : <span class="keyword">view</span>._listeningTo[<span class="string">'l1'</span>] &#125;</span><br><span class="line">model._event = &#123;<span class="string">'change'</span>:[&#123;callback: changeHandler, contex<span class="variable">t:</span> <span class="keyword">view</span>, ctx: <span class="keyword">view</span>, listenin<span class="variable">g:</span> <span class="keyword">view</span>._listeningTo[<span class="string">'l1'</span>]&#125;]&#125;</span><br></pre></td></tr></table></figure><p>view._listeningTo 的key 为model._listenId ， 也就是说，增加一个model实例，就会增加一个key，<br>例如再执行：<code>view.listenTo(model2,&#39;change&#39;,changeHandler)</code>。</p><p>所以通过_listeningTo属性，能够知道view与多少个model有关联。</p><p>这样，当执行<code>view.stopListening()</code>时，就能把model,model2上的监听事件全部移除了。</p><p>同样的,<br>model._listeners的key 为view._listenId, 例如:view2.listenTo(model,’change’,changeHandler)，<br>那么会再生成一个view2._listenId, model._listeners的key将多一个。</p><h2 id="为什么Backbone-Events会有listenTo和stopListening"><a href="#为什么Backbone-Events会有listenTo和stopListening" class="headerlink" title="为什么Backbone.Events会有listenTo和stopListening"></a>为什么Backbone.Events会有<strong>listenTo</strong>和<strong>stopListening</strong></h2><p>在很多的类库中使用的事件机制都是没有这两个方法的功能。</p><p>这两个方法更像是专为view,model而生的。<br>通过这两个方法可以方便的对view相关的对象监听事件进行跟踪，解绑。</p><h2 id="事件对象上的-events"><a href="#事件对象上的-events" class="headerlink" title="事件对象上的_events"></a>事件对象上的<code>_events</code></h2><p>如上的<code>model._events</code>，我们来分析下它里面有些什么：</p><p><code>model._events</code>它是一个对象 <code>: { key1 : value1, key2 : value2 , key3 : value3 ....}</code>。以事件名为key, value则是一组组数，数组内的每一元素又是一个对象</p><p>元素中的对象内容如下：</p><ul><li>callback  事件的回调函数</li><li>context   回调函数的上下文对象（即当调用<code>on</code>时，为context参数，当调用<code>view.listenTo(....)</code>时，为调用的对象如：view。）</li><li>ctx        为context ，当context不存在时，为被监听的对象，如：model.on(…)或view.on(model,…)中的model</li><li>listening 其实就是view._listeningTo中的某个属性值，可以看成: listening == view._listeningTo[‘l1’]</li></ul><h2 id="context与ctx"><a href="#context与ctx" class="headerlink" title="context与ctx"></a><code>context</code>与<code>ctx</code></h2><p>如上所述，每个元素里的 <code>context</code>与<code>ctx</code>几乎一样，那为什么需要两个属性呢。</p><p>通过阅读<code>off</code>方法及<code>trigger</code>方法就会知道，上面两属性在这两个方法中分别被使用了。</p><p>在<code>off</code>里需要对<code>context</code>进行比较决定是否要删除对应的事件，所以<code>model._events</code>中保存下来的 context,必须是未做修改的。</p><p>而<code>trigger</code>里在执行回调函数时，需要指定其作用域，当绑定事件时没有给定作用域，则会使用被监听的对象当回调函数的作用域。</p><p>比如下面的代码：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var <span class="keyword">model</span> = &#123;  name : <span class="string">'devsai'</span>  &#125;</span><br><span class="line">var changeHandler = function()&#123; console.<span class="built-in">log</span>(this.name)&#125;</span><br><span class="line">_.extend(<span class="keyword">model</span>,Backbone.Events)</span><br><span class="line"><span class="keyword">model</span>.on(<span class="string">'change'</span>,changeHandler)</span><br><span class="line"><span class="keyword">model</span>.trigger(<span class="string">'change'</span>);  <span class="comment">// print :  devsai</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">model</span>.off();</span><br><span class="line">var context = &#123; name : <span class="string">'SAI'</span>&#125;</span><br><span class="line"><span class="keyword">model</span>.on(<span class="string">'change'</span>,changeHandler,context)</span><br><span class="line"><span class="keyword">model</span>.trigger(<span class="string">'change'</span>);  <span class="comment">// print : SAI</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">model</span>.off()</span><br><span class="line">var view = &#123; name : <span class="string">'SAI listenTo'</span> &#125;</span><br><span class="line">_.extend(view,Backbone.Events)</span><br><span class="line">view.listenTo(<span class="keyword">model</span>,<span class="string">'change'</span>,changeHandler)</span><br><span class="line"><span class="keyword">model</span>.trigger(<span class="string">'change'</span>)   <span class="comment">// print : SAI listenTo</span></span><br></pre></td></tr></table></figure><p>在调用<code>trigger</code>时，可能会执行这部分代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ev = events[i])<span class="selector-class">.callback</span><span class="selector-class">.call</span>(ev.ctx)</span><br></pre></td></tr></table></figure><p>但这边，这种写法我是有疑惑的，就如 <code>ev.ctx</code>在没有context的情况下， ctx 才是obj(即被监听的对象),<br>为何不去掉ctx属性, 然后在<code>trigger</code>时，做context判断</p><p>例如把代码改成： </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">ev</span> = events[i]).callback.call(<span class="built_in">ev</span>.<span class="built_in">context</span> || <span class="built_in">ev</span>.obj)</span><br></pre></td></tr></table></figure><p>这样ctx属性就可以不去定义了。理解起来更直观。 </p><h2 id="内部函数-eventsApi"><a href="#内部函数-eventsApi" class="headerlink" title="内部函数 eventsApi"></a>内部函数 <strong>eventsApi</strong></h2><p><code>eventsApi</code>是内部的函数，所有对外的接口，都会直接或间接的调用它。复用率极高。</p><p>那<code>eventsApi</code>主要是干什么的呢。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var eventsApi = function(iteratee, events, <span class="built_in">name</span>, callback, opts) &#123;</span><br><span class="line">  var i = <span class="number">0</span>, names;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">name</span> &amp;&amp; <span class="built_in">typeof</span> <span class="built_in">name</span> === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="comment">// Handle event maps.</span></span><br><span class="line">    <span class="keyword">if</span> (callback !== void <span class="number">0</span> &amp;&amp; <span class="string">'context'</span> <span class="built_in">in</span> opts &amp;&amp; opts.context === void <span class="number">0</span>) opts.context = callback;</span><br><span class="line">    <span class="keyword">for</span> (names = _.keys(<span class="built_in">name</span>); i &lt; names.length ; i++) &#123;</span><br><span class="line">      events = eventsApi(iteratee, events, names[i], <span class="built_in">name</span>[names[i]], opts);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">name</span> &amp;&amp; eventSplitter.test(<span class="built_in">name</span>)) &#123;</span><br><span class="line">    <span class="comment">// Handle space-separated event names by delegating them individually.</span></span><br><span class="line">    <span class="keyword">for</span> (names = <span class="built_in">name</span>.split(eventSplitter); i &lt; names.length; i++) &#123;</span><br><span class="line">      events = iteratee(events, names[i], callback, opts);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Finally, standard events.</span></span><br><span class="line">    events = iteratee(events, <span class="built_in">name</span>, callback, opts);</span><br><span class="line">  &#125;</span><br><span class="line">  return events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用对外方法（如<code>on</code>,<code>listenTo</code>,<code>once</code>…）传入的是<code>&#39;change update&#39;,callback</code>或<code>{&#39;change&#39;:callback,&#39;change update&#39;:callback}</code>，而最终指向的内部API函数为单个事件：<code>eventName,callback</code>。</p><p>所以简单说，该方法对多事件进行解析拆分，遍历执行单个<code>&#39;eventname&#39;,callback</code>。</p><p>下面来具体说说<code>eventsApi</code>的参数</p><p><strong>iteratee</strong></p><p>是个函数，根据调用的对外接口不同，该函数也不同。</p><p>如：做绑定iteratee = onApi , onceMap; 做解绑 iteratee = offApi; 做触发 iteratee = triggerApi</p><hr><p><strong>events</strong></p><p>已有事件的集合，当前事件对象上绑定的所有事件</p><hr><p><strong>name</strong></p><p>事件名，来源于各对外接口传入的<code>name</code></p><p>有两种类型，string （例如：”change”,”change update”）,map object (例如：{“change”:function(){}, “update change”:function(){}})</p><hr><p><strong>callback</strong></p><p>回调函数，来源于各对外接口传入的<code>callback</code>,但它也不一定总是回调函数，当<em>name</em>为object时，<em>callbcak</em>可能是context。</p><hr><p><strong>opts</strong></p><p>根据调用的接口不同，有以下几种情况</p><ul><li><code>on</code> ,<code>listenTo</code>,<code>off</code> ,调用这三个接口时 <code>opts</code>是个对象，<br>存放着<code>{context: context,ctx: obj,listening: listening }</code><br>obj为被监听的对象（<code>off</code>时不需要），context为回调函数的上下文 , listening ,调用<code>listenTo</code>时存在。</li><li><code>once</code>,<code>listenToOnce</code> , 调用这两个接口时 <code>opts</code>是个函数(做解绑操作)</li><li><code>trigger</code> , 此时<code>opts</code>是个数组(args,为触发事件传时回调函数的参数)</li></ul><h2 id="内部函数-triggerEvents"><a href="#内部函数-triggerEvents" class="headerlink" title="内部函数 triggerEvents"></a>内部函数 <strong>triggerEvents</strong></h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> triggerEvents = function(events, <span class="built_in">args</span>) &#123;</span><br><span class="line">  <span class="built_in">var</span> <span class="built_in">ev</span>, i = -<span class="number">1</span>, l = events.<span class="built_in">length</span>, a1 = <span class="built_in">args</span>[<span class="number">0</span>], a2 = <span class="built_in">args</span>[<span class="number">1</span>], a3 = <span class="built_in">args</span>[<span class="number">2</span>];</span><br><span class="line">  switch (<span class="built_in">args</span>.<span class="built_in">length</span>) &#123;</span><br><span class="line">    case <span class="number">0</span>: <span class="keyword">while</span> (++i &lt; l) (<span class="built_in">ev</span> = events[i]).callback.call(<span class="built_in">ev</span>.ctx); <span class="built_in">return</span>;</span><br><span class="line">    case <span class="number">1</span>: <span class="keyword">while</span> (++i &lt; l) (<span class="built_in">ev</span> = events[i]).callback.call(<span class="built_in">ev</span>.ctx, a1); <span class="built_in">return</span>;</span><br><span class="line">    case <span class="number">2</span>: <span class="keyword">while</span> (++i &lt; l) (<span class="built_in">ev</span> = events[i]).callback.call(<span class="built_in">ev</span>.ctx, a1, a2); <span class="built_in">return</span>;</span><br><span class="line">    case <span class="number">3</span>: <span class="keyword">while</span> (++i &lt; l) (<span class="built_in">ev</span> = events[i]).callback.call(<span class="built_in">ev</span>.ctx, a1, a2, a3); <span class="built_in">return</span>;</span><br><span class="line">    default: <span class="keyword">while</span> (++i &lt; l) (<span class="built_in">ev</span> = events[i]).callback.<span class="built_in">apply</span>(<span class="built_in">ev</span>.ctx, <span class="built_in">args</span>); <span class="built_in">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为什么要这么写呢，根据它的函数注释的意思是说，在Backbone内部大部分的事件最多只有3个参数，对事件调用进行了优化，<br>先尝试使用<code>call</code>调用，尽量的不去使用<code>apply</code>调用，以此达到优化的目的。</p><p>这里有对call,apply性能对比测试 <a href="https://jsperf.com/call-apply-segu" target="_blank" rel="noopener">https://jsperf.com/call-apply-segu</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>欢迎大家来一起探讨，由于个人能力有限，如有描述不妥或不对之处，请及时联系我或评论我。</p><p>如果喜欢这篇文章，帮忙点个赞支持下。</p><p>如果希望看到后续其他Backbone源码解析文章，请点下关注，第一时间获得更多更新内容。</p>]]></content>
    
    <summary type="html">
    
      Backbone源码阅读首篇，主要讲了Backbone.Events，对内部代码进行了分析。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.devsai.com/tags/JavaScript/"/>
    
      <category term="Backbone" scheme="http://www.devsai.com/tags/Backbone/"/>
    
      <category term="源码" scheme="http://www.devsai.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Backbone系列篇之重拾Backbone</title>
    <link href="http://www.devsai.com/2016/12/09/backbone-01/"/>
    <id>http://www.devsai.com/2016/12/09/backbone-01/</id>
    <published>2016-12-08T16:00:00.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>为什么要重拾Backbone？ 嗯。 其实也不是现在才用，而是很久很久之前就在用了。</p><p>那就换了呗! 现在流行的框架这么多，Angularjs,Reactjs,Vuejs等等都是很好的选择。</p><p>那么问题来了，项目需要支持IE8，他们支持IE8吗？ ….. </p><p>而且为什么一定要换呢，Backbone也是有优点的。（这里不对各框架进行撕比，我相信，存在即合理）</p><p>还不如想想项目存在的问题，和如何解决这些问题。</p><h2 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h2><ul><li><p>项目中使用Backbone版本过旧</p></li><li><p>由于Backbone的灵活，导致了代码的凌乱。（项目经过几代人编写，开始[先驱者]还按Backbone的方式编写，可[后来者]越往后Backbone存在感越低，数据不用Model,View也只用了最初封装的，Events事件就更别提了。jQuery就是一切。 ）</p></li><li><p>由于第二点，使得代码越来越难维护</p></li></ul><p>第二点其实不能全怪Backbone的，大部分原因还是因为developer对backbone使用不得当，没有对代码组织好，代码规范没有严格要求。</p><p>又或许应该code review ，以保证代码的质量。</p><p>偷偷说下，我就是那个后来者。 （此处，请轻喷！！！）</p><h2 id="想达到的目标"><a href="#想达到的目标" class="headerlink" title="想达到的目标"></a>想达到的目标</h2><p>出于以上问题考虑，所以要重构代码（一言不合就重构）</p><p>争取做到以下几点：</p><ul><li><p>善用Backbone</p></li><li><p>完善模块化，提高代码整体的复用率</p></li><li><p>规范代码，提高代码的阅读性</p></li><li><p>添加注释，说明业务逻辑</p></li><li><p>添加测试案例，使代码更健壮 （感觉很难，但还是想尝试去做）</p></li></ul><p>好吧。看我意yin了这么多，说点有用的。</p><h2 id="前端MVC模式"><a href="#前端MVC模式" class="headerlink" title="前端MVC模式"></a>前端MVC模式</h2><p>MVC（model-view-control）模式，实际上是从三个经典的设计模式演变过来的：观察者模式，策略模式和复合模式。</p><p>也可能使用了工厂模式、装饰者模式等等模式，这要看mvc框架具体的实现方式。</p><ul><li><p>Model 用于封装、保存应用的逻辑数据，以及一些对数据的处理方法。Model不会去关心数据最终会显示成什么样。<br>一旦数据有变化一般通过一种机制将数据发布出去。</p></li><li><p>View 对数据的显示，理论来说不应包含任何业务逻辑。为了实现根据数据的改变更新显示，view通常需要监听相关model的变化。这一般由model实现的发布机制实现。在model上注册view的处理事件，model数据改变，view的处理事件就会触发。</p></li><li><p>Control model与view之间的组织、业务逻辑的处理。在Control中完成model与view的关联等等。</p></li></ul><h2 id="Backbone做了哪些"><a href="#Backbone做了哪些" class="headerlink" title="Backbone做了哪些"></a>Backbone做了哪些</h2><p>实际上Backbone将代码分成了两部分，只有Model和View，并没有Control。</p><p><img src="/images/2016/backbone/backbone-mv.png" alt=""></p><p>这是官网上的图，从图中可以看出，通过用户在界面(View)中的操作产生了数据，将数据传入Model,Model将数据与DB同步，<br>然后Model发布了’change’的事件告诉View,View再通过改变的数据重新的去渲染页面。</p><h2 id="Backbone为什么没有Controller"><a href="#Backbone为什么没有Controller" class="headerlink" title="Backbone为什么没有Controller"></a>Backbone为什么没有Controller</h2><p>前端通常没有或有极少的业务逻辑，更多的是UI逻辑，交互逻辑，根据用户的操作去出去回应。</p><p>所以，前端Controller相对比较简单。Backbone没有C，更多的是用事件来处理UI逻辑，或交互逻辑。</p><p>这里的事件可能会有两种:</p><ul><li>Backbone的事件</li><li>另外就是DOM或window的事件。</li></ul><h2 id="前端路由Router"><a href="#前端路由Router" class="headerlink" title="前端路由Router"></a>前端路由Router</h2><p>Router用来切换页面，根据URL的变化显示不同的内容，其实不仅前端，后端也是有路由的，<br>只不过后端的路由一般在Controller里，根据请求路径的不同执行Control中不同的方法。</p><p>感觉Ruoter是从Control抽出来得概念。</p><p><img src="/images/2016/backbone/router.png" alt=""></p><p>根据Router来确定，将要显示内容的View,及对应的Model。 </p><h2 id="接下来做什么"><a href="#接下来做什么" class="headerlink" title="接下来做什么"></a>接下来做什么</h2><p>之前对Backbone未作过多的了解，只是粗略的看了文档。为了能更好的重构项目，准备对源码进行拜读。</p><p>从而在实际项目使用过程中能对Backbone有更好的把控。</p><p>阅读顺序将按照<a href="http://backbonejs.org/" target="_blank">官方文档</a>先后顺序来，计划如下：</p><p><a href="/2016/12/10/backbone-events">Backbone系列篇之Backbone.Events源码解析</a></p><p>Backbone系列篇之Backbone.Model源码解析</p><p>Backbone系列篇之Backbone.Collection源码解析</p><p>Backbone系列篇之Backbone.Router源码解析</p><p>Backbone系列篇之Backbone.History和.Sync源码解析</p><p>Backbone系列篇之Backbone.View源码解析</p><p>尽情期待！！！</p>]]></content>
    
    <summary type="html">
    
      说说项目中使用Backbone存在的问题,及想要达到的目标。对Backbone重新研究。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.devsai.com/tags/JavaScript/"/>
    
      <category term="Backbone" scheme="http://www.devsai.com/tags/Backbone/"/>
    
  </entry>
  
  <entry>
    <title>Web开发之跨域与跨域资源共享</title>
    <link href="http://www.devsai.com/2016/11/24/talk-CORS/"/>
    <id>http://www.devsai.com/2016/11/24/talk-CORS/</id>
    <published>2016-11-23T16:00:00.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同源策略（same-origin-policy）"><a href="#同源策略（same-origin-policy）" class="headerlink" title="同源策略（same origin policy）"></a>同源策略（same origin policy）</h1><p>1995年，同源政策由 Netscape 公司引入浏览器。为了防止某些文档或脚本加载别的域下的未知内容，防止造成泄露隐私，破坏系统等行为发生。</p><p>同源策略做了两种限制:</p><ol><li>不能通过<em>ajax的方法</em>或<em>其他脚本中的请求</em>去访问不同源中的文档。</li><li>浏览器中不同域的框架之间是不能进行js的交互操作的。</li></ol><p>现在所有的可支持javascript的浏览器都会使用这个策略。</p><h2 id="怎么算同源"><a href="#怎么算同源" class="headerlink" title="怎么算同源"></a>怎么算同源</h2><p>URL的三部分完全相同时我们就可以称其为同源,这三部分是: <em><code>协议</code></em>，<em><code>域名（主机名）</code></em>和<em><code>端口</code></em>都相同。</p><h2 id="IE-例外"><a href="#IE-例外" class="headerlink" title="IE 例外"></a>IE 例外</h2><p>当涉及到同源策略时，Internet Explorer有两个主要的例外</p><pre><code>授信范围（Trust Zones）：两个相互之间高度互信的域名，如公司域名（corporate domains），不遵守同源策略的限制。端口：IE未将端口号加入到同源策略的组成部分之中，因此 http://company.com:81/index.html 和http://company.com/index.html  属于同源并且不受任何限制。</code></pre><h1 id="跨域的几种解决方法"><a href="#跨域的几种解决方法" class="headerlink" title="跨域的几种解决方法"></a>跨域的几种解决方法</h1><p>虽然同源策略很有必要，但有很多时候我们还是需要去请求其他域的数据，如：调用不同业务的数据，而不同业务已子域区分；又或者是第三方公用的数据接口等等</p><p>由于各种原因，我们需要通过各种方式来请求到不同域下的资源。</p><h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><p>jsonp是通过可以发出跨域请求的script标签,使javascript能够获得跨域请求的数据，并调用数据。</p><p>先看个例子：<br>文件index.js :</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">123</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>页面index.html:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当加载页面<code>index.html</code>后，出<code>123</code>内容的弹窗。通过查看<code>index.js</code>的响应体，会发现响应内容就是<code>alert(123)</code>。</p><p><img src="/images/2016/crossdomain/jsonp_1.png" alt=""></p><p>所以，可以这么思考，只要是通过script标签请求到的内容就会被当做js代码执行。</p><p>是否可以在script中的地址<code>src</code>不请求js文件，而是请求服务端的接口（即使不在同源下的），那么返回的内容就能获得到，并且会当成js代码来执行。（一般的script标签都会去请求js代码文件）</p><p>再来看下正常的服务端获取数据接口。</p><blockquote><p>   比如:有这么个接口<code>/getUserInfo/001</code>,通过ajax请求获得此接口数据<code>{&quot;data&quot; : {&quot;name&quot; : &quot;devsai&quot;,like:&quot;everything&quot;}}</code>。</p><p>   得到数据后在ajax中调用<code>showUserInfo(data)</code>来渲染页面，<code>data</code>就是接口数据。</p></blockquote><p>如果现在用script标签来请求数据,那么同样可以获得数据，执行返回到的内容，因是<code>json</code>格式的数据，并不会报错，但也并没有卵用。获得接口的数据肯定是想做些什么的。</p><p>再想想，正常ajax请求后的js执行内容<code>showUserInfo(data)</code>,拿到数据后，调用了<code>showUserInfo</code>函数。</p><p>那么，用script标签来请求数据时，返回的内容直接是<code>showUserInfo(data)</code>不就行了，但服务端又不知道我们到底要执行哪个函数，即使事先约定了，但后面因某些事要改，那还得告诉服务端，太麻烦了。<br>如果知道要执行什么函数就好了。</p><p>当然，这是可以的，改造下接口，以参数的形式把函数名传给服务端。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/jsonp/getUserInfo/001?jsonp_fn=showUserInfo"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Response返回的内容同样需要改造<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Response:</span></span><br><span class="line">showUserInfo(&#123;<span class="string">"data"</span> : &#123;<span class="string">"name"</span> : <span class="string">"devsai"</span>,<span class="string">like:</span><span class="string">"everything"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>这样，通过jsonp，去跨域请求接口数据就完成了。<br>需要注意的是函数名需要挂在<code>window</code>下面，要不然会报函数名未定义。</p><h2 id="改变源-origin-：通过document-domain与子域之间的跨域通讯"><a href="#改变源-origin-：通过document-domain与子域之间的跨域通讯" class="headerlink" title="改变源(origin)：通过document.domain与子域之间的跨域通讯"></a>改变源(origin)：通过document.domain与子域之间的跨域通讯</h2><p>例如在<code>demo.devsai.com/index.html</code>页面里执行如下内容：</p><pre><code>document.domain = &apos;devsai.com&apos;;</code></pre><p>执行该语句后，可以成功通过<code>devsai.com/index.html</code>的同源检测, 实现数据的通讯，<br>当然<code>document.domain</code>不能随意设置，只能设置成当前域，或设置成当前域的顶域。</p><p>document.domain常常被用于同站但不同域的情况，例如：<code>www.devsai.com</code>，下嵌入了iframe广告页面<code>ad.devsai.com</code>,想要实现两页面的通讯，就需要对两个页面都设置<code>document.domain=&#39;devsai.com&#39;</code>。</p><h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h2><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p><p>name只能是字符串。</p><p>页面a.html中:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.name = <span class="string">'page name index.html'</span>;</span></span><br><span class="line"><span class="actionscript">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.location = <span class="string">'http://localhost:8080/static/b.html'</span>;</span></span><br><span class="line"><span class="undefined">&#125;, 2000);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面b.html:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">alert(<span class="built_in">window</span>.name);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>再来看看如何让a.html页面获取数据</p><p>用data.html作为请求数据地址:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Data<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.name = <span class="string">'&#123; "name":"devsai","like" : "everything"&#125;'</span>; <span class="comment">// 需要传入 a.html页面的数据，必须是字符串</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>a.html：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/static/data.html"</span> <span class="attr">onload</span>=<span class="string">"getData();"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">id</span>=<span class="string">"iframe_1"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe_1'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//隐藏iframe</span></span></span><br><span class="line"><span class="actionscript">    iframe.setAttribute(<span class="string">"width"</span>, <span class="string">"0"</span>);</span></span><br><span class="line"><span class="actionscript">    iframe.setAttribute(<span class="string">"height"</span>, <span class="string">"0"</span>);</span></span><br><span class="line"><span class="actionscript">    iframe.setAttribute(<span class="string">"border"</span>, <span class="string">"0"</span>);</span></span><br><span class="line"><span class="actionscript">    iframe.setAttribute(<span class="string">"style"</span>, <span class="string">"width: 0; height: 0; border: none;"</span>);</span></span><br><span class="line"><span class="actionscript">    iframe.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(iframe.contentWindow.name);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> data = iframe.contentWindow.name;</span></span><br><span class="line"><span class="javascript">        data = <span class="built_in">JSON</span>.parse(data);<span class="comment">//转成 JSON</span></span></span><br><span class="line"><span class="undefined">        showUserInfo(data); </span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">    iframe.src = <span class="string">'about:blank'</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">showUserInfo</span><span class="params">(data)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// .....do something</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>当访问<code>http://127.0.0.1:8080/static/index.html</code>,便能获得来自不同域下<code>data.html</code>中的数据。</p><p>也可以做的更完善些，动态的生成iframe请求数据，用完即毁。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="comment">// 传入请求数据接口地址和回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestData</span>(<span class="params">url,successCB</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">    iframe.setAttribute(<span class="string">"id"</span>, <span class="string">"getDataByWindowName"</span>);</span><br><span class="line">    iframe.setAttribute(<span class="string">"width"</span>, <span class="string">"0"</span>);</span><br><span class="line">    iframe.setAttribute(<span class="string">"height"</span>, <span class="string">"0"</span>);</span><br><span class="line">    iframe.setAttribute(<span class="string">"border"</span>, <span class="string">"0"</span>);</span><br><span class="line">    iframe.setAttribute(<span class="string">"style"</span>, <span class="string">"width: 0; height: 0; border: none;"</span>);</span><br><span class="line">    iframe.setAttribute(<span class="string">"src"</span>, <span class="built_in">url</span>);</span><br><span class="line">    body.appendChild(iframe);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//防止iframe.src在没加载前就被替换</span></span><br><span class="line">        iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> data = iframe.contentWindow.name;</span><br><span class="line">            <span class="keyword">if</span>(data)&#123;</span><br><span class="line">                data = <span class="built_in">JSON</span>.parse(data);<span class="comment">//转成 JSON</span></span><br><span class="line">                successCB &amp;&amp; successCB(data);</span><br><span class="line">            &#125;</span><br><span class="line">            iframe.parentNode.removeChild(iframe);</span><br><span class="line">        &#125;</span><br><span class="line">        iframe.src = <span class="string">'about:blank'</span>;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//requestData("http://localhost:8080/static/data.html",showUserInfo);</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这就是使用window.name来进行跨域。</p><h2 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h2><p>window.postMessage方法是html5的新特性之一，<br>可以使用它来向其它的window对象发送消息，不管这个window对象是属于同源或不同源。</p><p>通过window.postMessage允许浏览器<strong>windows, tabs, and iFrames</strong>之间跨域通讯。</p><p>之前写过一篇关于<code>window.postMessage</code>的，做了详细的说明+演示页面+演示代码,<a href="http://www.devsai.com/2016/02/17/postMessage/" target="_blank">去看看</a></p><h2 id="服务端地址映射"><a href="#服务端地址映射" class="headerlink" title="服务端地址映射"></a>服务端地址映射</h2><p>例如一个网站上有各种不同的业务，不同的业务有其对应的子域。</p><p>如：<code>ad.devsai.com;upload.devsai.com;live.devsai.com</code>，分别对应广告业务，上传业务，直播业务。</p><p>想在<code>www.devsai.com</code>中做交互，或获得数据，便会受跨域影响。</p><p>造成跨域的原因是因为请求数据的源不同，那只要请求的源一样，便没有跨域问题了。</p><p>这也是可以办到的，只需要web服务做下代理，或称之为地址映射。</p><p>拿Nginx举例，需要在web服务上做如下配置：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">lcaotion <span class="string">/ad</span> &#123;</span><br><span class="line">proxy_pass http:<span class="string">//ad.devsai.com</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location <span class="string">/upload</span> &#123;</span><br><span class="line">proxy_pass http:<span class="string">//upload.devsai.com</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location <span class="string">/live</span> &#123;</span><br><span class="line">proxy_pass http:<span class="string">//live.devsai.com</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>然后就可以在以<code>www.devsai.com/ad/</code>的方式去调用广告业务。</p><h1 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h1><p>当一个发起的请求地址与发起该请求本身所在的地址不在同源下时，称该请求发起了一个跨域的HTTP请求。</p><p>有些的跨域请求是被允许的<code>&lt;img&gt;</code>,<code>&lt;script&gt;</code>,<code>&lt;link&gt;</code>图片，脚本，样式及其他资源 ，加载这些数据时即使不在同源下面也同样被允许，如今的网站通常也会去引用不在同源下的这些资源，如做CDN加速。</p><p>但也有些不被允许，正如大家所知，出于安全考虑，浏览器会“限制”脚本中发起的跨站请求，比如：XmlHttpRequest。</p><p>除了XmlHttpRequest外，还有以下几种跨域请求做了相应的安全限制。</p><p>比如：</p><p><strong>1</strong> 前面说的iframe，通过设置<code>src</code>可以发起跨域请求，但对请求到的内容进行操作就不被允许了。如执行<code>iframe.contentWindow.name</code>就会报错。</p><hr><p><strong>2</strong> <code>&lt;img&gt;</code>标签上<code>crossorigin</code>属性是一个CORS的配置属性，目的是为了允许第三方网站上的图片（即不在同源上的图片）能够在canvas中被使用。<br>如果没有配置改属性，又跨域请求了图片，当调用canvas中的<code>toBlob()</code>, <code>toDataURL()</code>, 或<code>getImageData()</code>方法的时候，会报错。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var <span class="attr">img</span> = new Image,</span><br><span class="line">    <span class="attr">canvas</span> = document.createElement(<span class="string">"canvas"</span>),</span><br><span class="line">    <span class="attr">ctx</span> = canvas.getContext(<span class="string">"2d"</span>),</span><br><span class="line">    <span class="attr">src</span> = <span class="string">"https://sf-sponsor.b0.upaiyun.com/45751d8fcd71e4a16c218e0daa265704.png"</span>; // insert image url here</span><br><span class="line">img.<span class="attr">crossOrigin</span> = <span class="string">"Anonymous"</span>;</span><br><span class="line"></span><br><span class="line">img.<span class="attr">onload</span> = function() &#123;</span><br><span class="line">    console.log(img);</span><br><span class="line">    canvas.<span class="attr">width</span> = img.width;</span><br><span class="line">    canvas.<span class="attr">height</span> = img.height;</span><br><span class="line">    ctx.drawImage( img, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">    localStorage.setItem( <span class="string">"savedImageData"</span>, canvas.toDataURL(<span class="string">"image/png"</span>) );</span><br><span class="line">&#125;</span><br><span class="line">img.<span class="attr">src</span> = src;</span><br></pre></td></tr></table></figure></p><hr><p><strong>3</strong> 同样的script也可以有<code>crossorigin</code>属性，<br>script本身没有跨域问题，不然jsonp就没法用了。但如果请求的不是同源下的js文件，发生错误后，无法通过window.onerror事件捕捉到详细的信息</p><p>例如加载index.js文件，其中a未定义:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var b</span> = a;</span><br></pre></td></tr></table></figure><p><em>同源下的 window.onerror报错信息</em></p><p><img src="/images/2016/crossdomain/error1.png" alt=""></p><p><em>跨域下的 window.onerror报错信息</em></p><p><img src="/images/2016/crossdomain/error2.png" alt=""></p><p>通过script标签上添加crossdomain属性,并在服务上配置响应头。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://lcoalhost:/static/index.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">crossdomain</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在去看onerror中的报错信息就和同源下的报错信息一样了。</p><hr><p><strong>4</strong> Web字体 (CSS 中通过 @font-face 使用跨站字体资源)，使用非同源地址，同样会报错。</p><p>还需要注意的一点是，跨域请求并非是浏览器限制了请求，而是浏览器拦截了返回结果。不管是否跨域，请求都会发送到服务端。<br>但也有特例，有些浏览器不允许从HTTPS的域跨域访问HTTP，比如Chrome和Firefox，这些浏览器在请求还未发出的时候就会拦截请求。</p><p>解决这类跨域问题的方法就是<code>*CORS*</code>，对于简单的请求来说，前端这边都不需要做任何的编码就能实现跨域请求，<br>只需要服务端配置响应头”Access-Control-Allow-Origin:*”。</p><h2 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是CORS</h2><p>CORS是一个W3C标准,全称“跨域资源共享”（Cross-origin resource sharing）</p><p>跨源资源共享标准通过新增一系列 HTTP 头，让服务器能声明哪些来源可以通过浏览器访问该服务器上的资源。</p><h2 id="CORS服务端设置-Set-Response-Header"><a href="#CORS服务端设置-Set-Response-Header" class="headerlink" title="CORS服务端设置(Set Response Header)"></a>CORS服务端设置(Set Response Header)</h2><p><strong>Access-Control-Allow-Origin</strong></p><p>根据Reuqest请求头中的<em>Origin</em>来判断该请求的资源是否可以被共享。</p><p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（该字段的值为服务端设置Access-Control-Allow-Origin的值）便知出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。此时HTTP的返回码为200，所以 这种错误无法通过状态码识别。</p><p><strong>Access-Control-Allow-Credentials</strong></p><p>指定是否允许请求带上cookies，HTTP authentication，client-side SSL certificates等消息。<br>如需要带上这些信息，<code>Access-Control-Allow-Credentials:true</code>并需要在XmlHpptRequest中设置<code>xhr.withCredentials=true</code>。</p><p>需注意的是，当设置了the credentials flag为true,那么<em>Access-Control-Allow-Origin</em>就不能使用”<code>*</code>“</p><p><strong>Access-Control-Max-Age</strong></p><p>可选字段，指定了一个预请求将缓存多久，在缓存失效前将不会再发送预请求。</p><p><strong>Access-Control-Allow-Methods</strong></p><p>作为预请求Response的一部分，指定了真实请求可以使用的请求方式。</p><p><strong>Access-Control-Allow-Headers</strong></p><p>作为预请求Response的一部分，指定了真实请求可以使用的请求头名称(header field names)。</p><h2 id="CORS两种请求方式"><a href="#CORS两种请求方式" class="headerlink" title="CORS两种请求方式"></a>CORS两种请求方式</h2><p>CORS的有两种请求方式： 简单请求(Simple Request) 和 预请求(Prefilght Request)</p><h2 id="简单请求-Simple-Request"><a href="#简单请求-Simple-Request" class="headerlink" title="简单请求(Simple Request)"></a>简单请求(Simple Request)</h2><p>只要同时满足以下三大条件，就属于简单请求。</p><p>a) 请求方式是以下几种方式之一</p><pre><code>* GET* POST* HEAD</code></pre><p>b) content-type必须是以下几种之一</p><pre><code>* application/x-www-form-urlencoded* multipart/form-data* text/plain</code></pre><p>c) 不会使用自定义请求头（类似于 X-Modified 这种）。</p><h2 id="预请求-Prefilght-Request"><a href="#预请求-Prefilght-Request" class="headerlink" title="预请求(Prefilght Request)"></a>预请求(Prefilght Request)</h2><p>如果不满足简单请求的三大条件，会在发送正真的请求前，发送个请求方式为’OPTIONS’的请求，去服务端做检测，</p><p>1） 请求方式不是GET,POST,HEAD</p><p>那么需要在响应HEAD配置允许的请求方式，例如：<code>Access-Control-Allow-Methods:PUT,DELETE</code></p><p>2) 使用自定义请求头,如x-devsai ，那么需要在服务端相应配置允许的自定义请求头:<code>Access-Control-Request-Headers: x-devsai</code></p><p>一旦检测不通过，浏览器就会提示相应的报错，并不会发生真实的请求。</p><h2 id="CORS兼容性"><a href="#CORS兼容性" class="headerlink" title="CORS兼容性"></a>CORS兼容性</h2><p><img src="/images/2016/crossdomain/cors_jrx.png" alt=""></p><p>从上图可只IE11,以下的就不支持CORS了。但实际上再IE8,IE9,IE10中，可以用XDomainRequest对象代替XmlHttpReuqest，发送跨域请求。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> <span class="type">XDomainRequest</span>(); </span><br><span class="line"></span><br><span class="line">xdr.open(<span class="string">"get"</span>, <span class="string">"http://www.devsai.com/xdr"</span>);</span><br><span class="line"></span><br><span class="line">xdr.send();</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>最后，总结下各种跨域方案的特点，还记得本文开始说的，同源策略的两种限制吗？</p><blockquote><ol><li>不能通过<strong>ajax的方法</strong>或<strong>其他脚本中的请求</strong>去访问不同源中的文档。</li><li>浏览器中不同域的框架之间是不能进行js的交互操作的。</li></ol></blockquote><p>把第1种标记为<strong>TYPE_1</strong>,第二种标记为<strong>TYPE_2</strong>，对上述的几种解决跨域的方法分下类。</p><p><strong>window.name</strong>  需要注意name只能是字符串</p><p>解决的限制 ：<strong>TYPE_1</strong>,<strong>TYPE_2</strong></p><p>缺点： 接口返回的内容必须都是html里嵌入script脚本。</p><hr><p><strong>document.domain</strong>  通过修改domain跨子域</p><p>解决的限制 ：<strong>TYPE_2</strong></p><p>缺点： 仅支持同个域下的子域跨域，跨域能力有限</p><hr><p><strong>window.postMessage</strong> 用于iframe、window、tabs之间的跨域通讯</p><p>解决的限制 ：<strong>TYPE_2</strong></p><p>缺点： 兼容问题，IE10以下受限，IE8以下无效</p><hr><p><strong>jsonp</strong> 是之前最常用的解决跨域请求的方法。</p><p>解决的限制 ：<strong>TYPE_1</strong></p><p>缺点： 不能用于<code>POST</code>请求</p><hr><p><strong>服务端地址映射</strong>  前端不需要管，并能解决跨域请求问题的一种方法。</p><p>解决的限制 ：<strong>TYPE_1</strong></p><p>缺点： 非要说缺点，那就是要说服服务端同学,而且一般场子铺大了的公司只用同源，不太可能。</p><hr><p><strong>CORS</strong> 感觉目前比较常用的解决跨域请求的方法。</p><p>解决的限制 ：<strong>TYPE_1</strong></p><p>缺点:  也是兼容性问题</p><p>真正开发过程中，需针对不同情况，使用不同的解决之法。</p>]]></content>
    
    <summary type="html">
    
      比较全的介绍了多种方案解决跨域相关问题。并对跨域资源共享做了介绍。
    
    </summary>
    
    
      <category term="HTML5" scheme="http://www.devsai.com/tags/HTML5/"/>
    
      <category term="CORS" scheme="http://www.devsai.com/tags/CORS/"/>
    
      <category term="jsonp" scheme="http://www.devsai.com/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之Https从无到有</title>
    <link href="http://www.devsai.com/2016/11/21/tech-https-30min/"/>
    <id>http://www.devsai.com/2016/11/21/tech-https-30min/</id>
    <published>2016-11-20T16:00:00.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇不讲什么是https，什么是SSL,什么是nginx</p><p>想了解这些的请绕道，相信有很多优秀的文章会告诉你。</p><p>本篇要讲的在最短的时间内，让你的网站从http升级到https。</p><p>开始教程前再说一句：https你值得拥有。</p><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近段时间，微信小程序爆火，消息一出，各路豪杰，摩拳擦掌，跃跃欲试。</p><p>都想这个坑(这里不多阐述，具体坑不坑，developer最清楚)里跳。微信对小程序也是有诸多的限制。</p><p>例如文件大小，请求服务端必须是https。 </p><p>文件大小，好办，开发过程中尽量的控制文件，能复用的尽量复用。用不到的文件尽量不引用。本地的图片也尽量的少。</p><p>可https,在国内线上用https的都不算多，更何况是开发过程中用https，应该就更少了吧。</p><p>如果你正在开发微信小程序，并还没有https，那么巧了，那么我想，这篇可能可以帮到你。</p><h1 id="StartSSL免费SSL证书"><a href="#StartSSL免费SSL证书" class="headerlink" title="StartSSL免费SSL证书"></a>StartSSL免费SSL证书</h1><p>都说了是开发用（如果到了线上，想要https，相关的运维人员会搞定收费的https），那当然要用免费的。</p><p>StartSSL就是个不错的选择。 </p><h2 id="StartSSL"><a href="#StartSSL" class="headerlink" title="StartSSL"></a>StartSSL</h2><p>StartSSL是StartCom公司旗下的SSL证书，提供免费SSL证书服务并且被主流浏览器支持的免费SSL，包括Chrome、Firefox、IE等浏览器都可以正常识别StartSSL，更主要的是StartSSL提供免费<code>3年</code>且可以无限续期的SSL证书，而且可以设置<code>10个</code>域名。</p><h2 id="StartSSL注册、登录"><a href="#StartSSL注册、登录" class="headerlink" title="StartSSL注册、登录"></a>StartSSL注册、登录</h2><p>1 进入注册页面</p><p>进入<a href="https://www.startssl.com/SignUp" target="_blank" rel="noopener">https://www.startssl.com/SignUp</a>。</p><p><img src="/images/2016/ssl/sginUp.png" alt=""></p><p>2 注册很简单只需要填个邮箱发送验证码</p><p><img src="/images/2016/ssl/verification.png" alt=""></p><p>3 然后填入获得的验证码,点击按钮后会跳转至设置密码</p><p><img src="/images/2016/ssl/sginUp2.png" alt=""></p><p><img src="/images/2016/ssl/sginUpsuccess.png" alt=""></p><p>4 注册成功后，会让你下载用于登录的证书，因为该网站提供了两种登录方式，客户端证书认证和邮箱登录（填写邮箱，获得验证码登录），个人感觉使用邮箱也很方便。</p><p><img src="/images/2016/ssl/login.png" alt=""></p><h2 id="申请免费的SSL"><a href="#申请免费的SSL" class="headerlink" title="申请免费的SSL"></a>申请免费的SSL</h2><p>1 先添加验证域名，选择选项卡的<code>Validations Wizard</code>，并选择<code>Domain Validation (for SSL certificate)</code><br>点击<code>Validation</code></p><p><img src="/images/2016/ssl/domainvalid.png" alt=""></p><p>2 填入域名，并在域名所有者邮箱（或域名对应的企业邮箱）中获取发送的验证码</p><p><img src="/images/2016/ssl/inputdoamin.png" alt=""></p><p>3 添加的域名验证成功，点击<code>To &quot;Order SSL Certificate &quot;</code></p><p><img src="/images/2016/ssl/validsuccess.png" alt=""></p><p>4 现在可以开始给自己的域名申请StartSSL免费SSL证书了，这里添加用于申请证书的完整的域名</p><p><img src="/images/2016/ssl/addfulldomain.png" alt=""></p><p>5 申请StartSSL免费SSL时，会要求填入CSR</p><p><img src="/images/2016/ssl/gencert.png" alt=""></p><p>6 CSR 生成可以有两种方式，一种是使用StartSSL提供的<code>[StartComTool.exe](https://download.startpki.com/startcom/startcomtool.exe)</code>适用于Window，另一种方式也可以使用<code>openssl</code>命令,适用于Mac,liunx等。</p><pre><code>openssl req -newkey rsa:2048 -keyout yourname.key -out yourname.csr</code></pre><p><img src="/images/2016/ssl/localgen.png" alt=""></p><p>7 把生成的(<code>youname.csr</code>)CSR签名证书请求内容，粘贴进去</p><p><img src="/images/2016/ssl/pastecert.png" alt=""></p><p>8 然后StartSSL就可以免费SSL下载使用</p><h2 id="下载免费的SSL"><a href="#下载免费的SSL" class="headerlink" title="下载免费的SSL"></a>下载免费的SSL</h2><p>下载下来的SSL是zip格式的压缩包，解压后有如下内容</p><p><img src="/images/2016/ssl/downloadunzip.png" alt=""></p><p>分别提供了几种web服务所需的ssl认证文件</p><h1 id="nginx-SSL配置"><a href="#nginx-SSL配置" class="headerlink" title="nginx SSL配置"></a>nginx SSL配置</h1><p>这里只拿nginx举例,编辑nginx配置文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">listen       <span class="number">443</span>;</span><br><span class="line">ssl     on;</span><br><span class="line">ssl_certificate <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>conf<span class="regexp">/key/</span>xxx.pem;</span><br><span class="line">ssl_certificate_key <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>conf<span class="regexp">/key/</span>xxx.key;</span><br><span class="line">ssl_session_timeout <span class="number">5</span>m;</span><br><span class="line">ssl_protocols TLSv1 TLSv1<span class="number">.1</span> TLSv1<span class="number">.2</span>;</span><br><span class="line">ssl_ciphers   EECDH+<span class="string">CHACHA20:</span>EECDH+CHACHA20-<span class="string">draft:</span>EECDH+<span class="string">AES128:</span>RSA+<span class="string">AES128:</span>EECDH+<span class="string">AES256:</span>RSA+<span class="string">AES256:</span>EECDH+<span class="number">3</span><span class="string">DES:</span>RSA+<span class="number">3</span><span class="string">DES:</span>!MD5;</span><br><span class="line">ssl_session_cache          <span class="string">shared:</span><span class="string">SSL:</span><span class="number">50</span>m;</span><br></pre></td></tr></table></figure><p><code>xxx.pem</code>就是从StartSSL下载下来的NginxServer.zip中的文件xxx_bundle.crt（需要把后缀改成pem）</p><p><code>xxx.key</code> 这是之前执行 <code>openssl req -newkey rsa:2048 -keyout yourname.key -out yourname.csr</code>时生成的key.</p><p>然后启动nginx ,输入密码（该密码是生成本地CSR时设置的）</p><p><img src="/images/2016/ssl/inputPEM.jpg" alt=""></p><h1 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h1><p>到这来，就可以使用https了，马上打开你的域名试试吧。</p><p>其实在网上也能找到很多StartSSL的申请流程。可大多都是之前的，界面与操作方式都有所改变。这篇提供了最新的StartSSL申请流程，以帮助大家更快的进行SSL认证。</p><p>看之前的教程，会告诉你，在第7步后不能马上下载SSL认证，StartSSL会有个客服审核的过程可能需要几小时，但现在的使用下来发现，现在已经没有这过程了，完成第7步就可以去认证的列表下载SSL认证。</p><h1 id="微信小程序请求-wx-request-fail"><a href="#微信小程序请求-wx-request-fail" class="headerlink" title="微信小程序请求 wx.request :fail"></a>微信小程序请求 wx.request :fail</h1><p>本文的目的是为了微信小程序请求能使用https</p><p>所以，最后如果在调用微信wx.request接口时还是报错，可以参考<a href="http://www.wxapp-union.com/forum.php?mod=viewthread&tid=648&highlight=request" target="_blank">这篇</a>寻找解决之法。</p>]]></content>
    
    <summary type="html">
    
      30分钟，https个人认证教程，以最快的速度拥有https
    
    </summary>
    
    
      <category term="https" scheme="http://www.devsai.com/tags/https/"/>
    
      <category term="ssl" scheme="http://www.devsai.com/tags/ssl/"/>
    
      <category term="微信小程序" scheme="http://www.devsai.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Web上传</title>
    <link href="http://www.devsai.com/2016/11/08/talk-web-upload/"/>
    <id>http://www.devsai.com/2016/11/08/talk-web-upload/</id>
    <published>2016-11-07T16:00:00.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web上传的实现方式"><a href="#web上传的实现方式" class="headerlink" title="web上传的实现方式"></a>web上传的实现方式</h1><ul><li>表单提交上传</li><li>iframe表单提交上传</li><li>flash上传</li><li>h5上传—xhr2上传（h5中规定的xhr2，也可称之ajax上传）</li><li>h5上传—websocket上传</li></ul><h1 id="表单提交上传"><a href="#表单提交上传" class="headerlink" title="表单提交上传"></a>表单提交上传</h1><h2 id="表单出生"><a href="#表单出生" class="headerlink" title="表单出生"></a>表单出生</h2><p>1995年十一月在<a href="https://www.ietf.org/rfc/rfc1866.txt" target="_blank" rel="noopener">RFC 1866</a>中第一次出现了<code>form</code>标签，在其中还出现了很多其他的标签也一直使用到现在。同年同月在<a href="https://www.ietf.org/rfc/rfc1867.txt" target="_blank" rel="noopener">RFC 1867</a>中在<code>form</code>的基础上提出了html关于文件的上传的建议,</p><h2 id="普通表单提交与上传表单提交区别"><a href="#普通表单提交与上传表单提交区别" class="headerlink" title="普通表单提交与上传表单提交区别"></a>普通表单提交与上传表单提交区别</h2><p>普通表单</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">form</span> action=<span class="string">"/"</span> &gt;</span><br><span class="line">&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span>&gt;&lt;/<span class="keyword">input</span>&gt;</span><br><span class="line">&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;&lt;/<span class="keyword">input</span>&gt;</span><br><span class="line">&lt;button <span class="keyword">type</span>=<span class="string">"submit"</span>&gt;确定&lt;/button&gt;</span><br><span class="line">&lt;/<span class="keyword">form</span>&gt;</span><br></pre></td></tr></table></figure><p>上传表单</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/upload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"images/*"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上传表单中，对<code>form</code>标签的<code>enctype=&quot;multipart/form-data&quot;</code>。</p><p>而普通的表单提交，一般不用去定义该属性，存在个默认的值“<em>x-www-form-urlencoded</em>”。</p><p>在<a href="https://www.ietf.org/rfc/rfc1867.txt" target="_blank" rel="noopener">RFC 1867</a>中，对<code>input</code>标签type属性添加了新的值<code>file</code>，也为<code>input</code>标签添加了一个新的属性<code>accept</code>来过滤上传文件的类型。</p><p>同时也定义了一个新的<code>MIME media type</code>：<code>multipart/form-data</code>,在<code>form</code>标签中定义<code>enctype=&quot;multipart/form-data&quot;</code>。</p><p>在点击提交时，两者的请求头与请求体也有所不同。</p><p>普通表单提交</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#request header</span></span><br><span class="line"><span class="type">Content</span>-<span class="class"><span class="keyword">type</span> : x-www-form-urlencoded;setchart:<span class="type">UTF</span>-8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#request body</span></span><br><span class="line"><span class="title">form</span>-<span class="class"><span class="keyword">data</span></span></span><br><span class="line"><span class="title">name</span>:xxx</span><br><span class="line"><span class="title">age</span>:<span class="number">111</span></span><br></pre></td></tr></table></figure><p>上传表单提交</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#request header</span></span><br><span class="line">Content-type : multipart/form-data; boundary=<span class="comment">----WebKitFormBoundaryK8NOU66bOhWkzidB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#request body</span></span><br><span class="line"><span class="comment">------WebKitFormBoundaryK8NOU66bOhWkzidB</span></span><br><span class="line">Content-Disposition: form-data; <span class="built_in">name</span>=<span class="string">"resume"</span>; filename=<span class="string">"test-text-file.txt"</span></span><br><span class="line">Content-Type: <span class="built_in">text</span>/plain</span><br><span class="line">Test <span class="built_in">text</span> <span class="built_in">file</span> <span class="keyword">for</span> testing <span class="built_in">file</span> uploads.</span><br><span class="line"><span class="comment">------WebKitFormBoundaryK8NOU66bOhWkzidB--</span></span><br></pre></td></tr></table></figure><p>上传表单提交，除了在Content-type中改变了MIME type,同时在其后添加了个属性<code>boundary</code>，用于表示提交的表单中各个字段的边界分割，不同浏览器生产的这个边界字符串是不同的。如上例子中的<code>----WebKitFormBoundaryK8NOU66bOhWkzidB</code>也只是使用webkit内核的才会出现<code>----WebKitForm</code>。</p><p><strong>表单上传提交的优缺点</strong></p><p>对现在的web上传来说，那时候的表单上传没什么优点，非要说优点，那就是简单，简单到不需要些一行JS代码。</p><p>说缺点的话，那就是一箩筐了。<br>上传文件会页面跳转，不能选择多文件上传（想要上传多文件，就必须有多个<code>input</code>），不能限制上传大小，不能获得上传进度信息，不能预览，等等所有现在的上传需要都无法满足。</p><p>PS:<br>HTML5中对<code>&lt;input type=&quot;file&quot;&gt;</code>添加了个新属性<code>multiple</code>，使之能够选择多文件，从而让表单上传提交变得方便。但话说，都有HTML5了，还需要用这种页面跳转的方式做上传吗？</p><p>HTML5也添加了文件对象(<code>File</code>)，可以方便的获得文件本身的一些信息，name,size,type，在上传前知道文件的大小，实现限制上传大小；</p><h1 id="iframe表单上传提交"><a href="#iframe表单上传提交" class="headerlink" title="iframe表单上传提交"></a>iframe表单上传提交</h1><p>是表单上传提交的优化版，本质上也是表单上传提交，一般都是通过创建个隐藏的iframe来提交表单，以此达到页面不跳转上传。</p><p>thml代码</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=<span class="string">"<span class="keyword">POST</span>"</span> action=<span class="string">"/iframeUpload"</span> id=<span class="string">"my_form"</span> enctype=<span class="string">"multipart/form-data"</span> &gt;</span><br><span class="line">    &lt;div class=<span class="string">"form-group"</span>&gt;</span><br><span class="line">       &lt;a href=<span class="string">"javascript:;"</span> class=<span class="string">"btn btn-default chooseFile"</span>&gt;选择文件</span><br><span class="line">          &lt;input type=<span class="string">"file"</span> name=<span class="string">"inputFile"</span>   id=<span class="string">"inputFile"</span> /&gt;&lt;/a&gt;</span><br><span class="line">        &lt;button  id=<span class="string">"submit_btn"</span> type=<span class="string">"submit"</span> onclick=<span class="string">"fileUpload();"</span>&gt;Upload&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>javascript代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//...get data ,or do somthing..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileUpload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'my_form'</span>);</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.setAttribute(<span class="string">"id"</span>, <span class="string">"upload_iframe"</span>);</span><br><span class="line">    iframe.setAttribute(<span class="string">"name"</span>, <span class="string">"upload_iframe"</span>);</span><br><span class="line">iframe.setAttribute(<span class="string">"width"</span>, <span class="string">"0"</span>);</span><br><span class="line">iframe.setAttribute(<span class="string">"height"</span>, <span class="string">"0"</span>);</span><br><span class="line">iframe.setAttribute(<span class="string">"border"</span>, <span class="string">"0"</span>);</span><br><span class="line">iframe.setAttribute(<span class="string">"style"</span>, <span class="string">"width: 0; height: 0; border: none;"</span>);</span><br><span class="line">form.parentNode.appendChild(iframe);</span><br><span class="line">iframeId.addEventListener(<span class="string">"load"</span>, eventHandler, <span class="literal">true</span>);</span><br><span class="line">iframeId.attachEvent(<span class="string">"onload"</span>, eventHandler);</span><br><span class="line">form.submit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可表单上传提交的其他缺点还是存在。</p><p>还是不能获得上传进度信息，想要获得上传进度信息，需要服务端的支持，轮询服务端接口。</p><p>并且iframe无法实现跨域上传</p><p>所以总体来说，iframe更适合上传单个文件，并上传的文件较小（文件较大 ，没有进度条信息的话，用户体验太差）。</p><h1 id="flash上传"><a href="#flash上传" class="headerlink" title="flash上传"></a>flash上传</h1><p>在HTML5之前，最流行的上传方式，能实现的功能也较多。</p><h2 id="flash上传的优点"><a href="#flash上传的优点" class="headerlink" title="flash上传的优点"></a>flash上传的优点</h2><ol><li>支持上传进度条</li><li>支持预览（图片等）</li><li>支持多文件上传</li><li>支持图片压缩</li><li>支持分片上传</li><li>支持暂停上传</li><li>支持秒传</li></ol><h2 id="flash上传的缺点"><a href="#flash上传的缺点" class="headerlink" title="flash上传的缺点"></a>flash上传的缺点</h2><ol><li>需要浏览器安装flash插件</li><li>网站需要加载相应的swf文件</li><li>对移动端不兼容（iOS一直不支持，Android5.0之后也不支持）</li></ol><h2 id="flash跨域上传"><a href="#flash跨域上传" class="headerlink" title="flash跨域上传"></a>flash跨域上传</h2><p>如果网站的地址，与上传请求的地址不是同域，则会存在flash数据传输跨域问题。</p><p>需要在请求地址的服务端根目录下添加<code>crossdomain.xml</code>文件</p><p>文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">cross-domain-policy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">allow-access-from</span> <span class="attr">doamin</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cross-domain-prolicy</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="H5—xhr2（XmlHttpRequest-level-2）上传"><a href="#H5—xhr2（XmlHttpRequest-level-2）上传" class="headerlink" title="H5—xhr2（XmlHttpRequest level 2）上传"></a>H5—xhr2（XmlHttpRequest level 2）上传</h1><p>xhr即我们常说的ajax(Asynchronous JavaScript and XML)</p><p><strong>xhr2的特点</strong></p><ol><li>可以设置HTTP请求的时限。</li><li>可以获取服务器端的（或向服务端发送）二进制数据。</li><li>可以使用FormData对象管理表单数据。</li><li>可以上传文件。<code>xhr.upload</code>(upload = XMLHttpRequestUpload)</li><li>可以获得数据传输的进度信息, <code>xhr.upload.onprogess</code>。</li><li>可以请求不同域名下的数据（跨域请求）。</li></ol><p>主要javascript代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadFile</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">   xhr.open(<span class="string">'POST'</span>,<span class="string">'/upload'</span>,<span class="literal">true</span>);</span><br><span class="line">   <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">   xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> per = <span class="built_in">Math</span>.ceil((data.loaded/data.total)*<span class="number">100</span>);</span><br><span class="line">      <span class="comment">//$('#'+file.uid+' .progress-bar').css('width',per+'%');</span></span><br><span class="line">   &#125;</span><br><span class="line">   xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">         <span class="comment">// Every thing ok, file uploaded</span></span><br><span class="line">           <span class="keyword">var</span> res = <span class="built_in">JSON</span>.parse(xhr.responseText);</span><br><span class="line">           <span class="keyword">if</span>(res.code ==<span class="number">200</span>)&#123;</span><br><span class="line">               <span class="comment">// upload success</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   formData.append(<span class="string">"upload_file"</span>, file);</span><br><span class="line">   formData.append(<span class="string">"filename"</span>,file.name);</span><br><span class="line">   xhr.send(formData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xhr2在结合H5的其他特性，可以实现上述flash上传的所以功能外，还可以实现<code>拖拽上传</code>功能。</p><p>由于诸多HTML5特性（Blob ,xhr2,FileReader,ArrayBuffer等）在IE10+中才有效，<br>所以xhr2上传更适合在chrome，firefox等高版本的浏览器或和移动端使用。</p><h1 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS(跨域资源共享)"></a>CORS(跨域资源共享)</h1><p>允许一个域上的网络应用向另一个域提交跨域 AJAX 请求。启用此功能非常简单，只需由服务器发送一个响应标头即可。例如：<br><code>Access-Control-Allow-Origin: http://example.com</code></p><p>当然还有其他的一些配置，比如配置允许的自定义头，允许的请求方式等等。这里不作详细说明，具体内容可查看<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS?redirectlocale=en-US&redirectslug=HTTP_access_control#Preflighted_requests" target="_blank">这里</a></p><p><img src="/images/cors.png" alt="cors"><br>这图清晰的整个跨域资源共享的请求过程。</p><h1 id="H5—websocket上传"><a href="#H5—websocket上传" class="headerlink" title="H5—websocket上传"></a>H5—websocket上传</h1><p>二话不说，上代码:</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">url</span> = <span class="string">"ws://localhost:8081/upload"</span>;</span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="built_in">url</span>);</span><br><span class="line">ws.binaryType = <span class="string">'arraybuffer'</span>;</span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.console.log(<span class="string">'websocket connection success ...'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ws.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.console.log(<span class="string">'WebSocket Error '</span> + error);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadFile</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//实例化FileReader对象</span></span><br><span class="line">   <span class="keyword">var</span> fr = <span class="keyword">new</span> FileReader();</span><br><span class="line">   <span class="comment">//定义文件加载完的监听事件，执行回调函数 </span></span><br><span class="line">   fr.addEventListener(<span class="string">"loadend"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      ws.send(fr.result);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//把文件加载进ArrayBuffer中</span></span><br><span class="line">   fr.readAsArrayBuffer(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际使用中，浏览器websocket用做上传较少</p><p>websocket上传存在几个问题：</p><ol><li>一般对于现有的上传服务，服务端需要单独开发接口</li><li>同样无法获得上传的进度信息（变通方式：必须使用分片来模拟进度）</li></ol><h1 id="简单比较几种上传组件"><a href="#简单比较几种上传组件" class="headerlink" title="简单比较几种上传组件"></a>简单比较几种上传组件</h1><p><em>swfupload</em></p><p>flash实现的上传组件，在h5或移动端未流行的时候，是比较常用的上传方式。<br>理由是功能强大。</p><p><em><a href="https://blueimp.github.io/jQuery-File-Upload/" target="_blank">jQuery-File-Upload</a></em></p><p>在github上的人气相当的高，是上述所说iframe与xhr2上传的结合，介绍说支持IE6以上浏览器的上传功能。</p><p>此话也不假，iframe用的就是form表单提交上传，确实可以在IE7，IE8等浏览器中完成上传。<br>但也就是上传，上传相关的其他”特效功能”都实现不了。所以在我看来，jQuery-File-Uplaod更适合用于chrome ,firefox等或移动端的上传。</p><p><em><a href="http://www.uploadify.com" target="_blank">Uploadify</a></em></p><p>是个基于swfupload的上传组件，同时也支持xhr2上传。是falsh上传与xhr2上传的结合，同样的功能强大。对浏览器的兼容要比jQuery-File-Upload要更好。</p><p><em><a href="http://fex.baidu.com/webuploader/" target="_blank">webUploder</a></em></p><p>与Uploadify一样是falsh上传与xhr2上传的结合，但从查看两者的API会发现，webUploader实现的功能要更多，更强大。 比如：分片上传，MD5秒传，图片压缩上传</p><p>最后双手奉上<a href="https://github.com/huangxiangsai/web-upload-demo" target="_blank">web上传Demo</a></p>]]></content>
    
    <summary type="html">
    
      对 web 上传的多种解决方案进行了总结，从最简单的上传说起，说到常用的上传方案。最后对几种常用的上传组件进行了介绍。
    
    </summary>
    
    
      <category term="HTML5" scheme="http://www.devsai.com/tags/HTML5/"/>
    
      <category term="upload" scheme="http://www.devsai.com/tags/upload/"/>
    
  </entry>
  
  <entry>
    <title>Git命令的使用场景</title>
    <link href="http://www.devsai.com/2016/07/19/git%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://www.devsai.com/2016/07/19/git命令使用场景/</id>
    <published>2016-07-18T16:00:00.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中不断的使用git,就会继续的遇到新的问题。</p><p>本篇会用场景带入的方式来说明我们在不同的时候使用不同的命令。</p><h3 id="场景1-烦人的密码"><a href="#场景1-烦人的密码" class="headerlink" title="场景1 (烦人的密码)"></a>场景1 (烦人的密码)</h3><p>有时会遇到这样的问题，每次做 <code>git push</code> 的时候都要求输入用户名密码。</p><p>有些人会想，我都添加了SSH key了为什么还要输入用户名密码。这时候你可以看下项目中 <code>.git/config</code><br>中remote远程地址是什么，如果是<code>http://...</code>这种形式的，恭喜问题找到了，把它改成<code>git@...</code>这种形式的地址<br>就不再要求输入用户名密码了。</p><p>可就是想用<code>http://...</code>这种形式的呢，也是有办法的，但这就跟SSH key没有半毛钱关系了。<br>我们可以添加配置项把用户名密码保存在本地，不用每次提交都输用户名密码了 </p><p><code>git config --global credential.helper store</code></p><p>设置了这个后，再执行<code>git push ..</code>会提示输入用户名密码，但输入这次 之后就不会再要求输入用户名密码了</p><h3 id="场景2-保护现场"><a href="#场景2-保护现场" class="headerlink" title="场景2 (保护现场)"></a>场景2 (保护现场)</h3><p>我们正在开发一新功能，这时产品跑过来说有个非常紧急的小需求要开发。非常紧急的，优先级最高的那种，你们懂得。</p><p>可这是开发的新功能才写了一半的code,怎么办呢。如果不用git，我们可能会这样：</p><p>把现有的代码copy一份，在到服务器拉份最新的代码下来，然后开发那个非常紧急的需求。</p><p>当然这种做法很明显，很龊，很低效。</p><p>现在我们使用git了，我们有’银弹’ ：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash </span><br><span class="line"></span><br><span class="line">git stash <span class="keyword">pop</span></span><br></pre></td></tr></table></figure><p>第一个命令在我们突然有新需求插入时使用，它会保存下当前所有的修改文件，使工作区变成无修改的状态。</p><p>这时就可以开发新需求了，可能中间会有一系列的命令<code>git add . &gt;&gt; git commit &gt;&gt; git push origin dev</code>等等</p><p>在插入的新需求完成之后，就可以使用<code>git stash pop</code>把之前临时保存coding了一半的代码找回来，继续开发。</p><h3 id="场景3-同一个问题，修复了N-1次，提交了N-1次，提交记录没法看怎么办"><a href="#场景3-同一个问题，修复了N-1次，提交了N-1次，提交记录没法看怎么办" class="headerlink" title="场景3 (同一个问题，修复了N+1次，提交了N+1次，提交记录没法看怎么办)"></a>场景3 (同一个问题，修复了N+1次，提交了N+1次，提交记录没法看怎么办)</h3><p>作为前端，遇到产品频繁改需求是比较常见的，所以很可能，同一点要改上很多次</p><blockquote><pre><code>持续更新中......</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      在开发中不断的使用git,就会继续的遇到新的问题。
本篇会用场景带入的方式来说明我们在不同的时候使用不同的命令。
    
    </summary>
    
    
      <category term="git" scheme="http://www.devsai.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git出错 Fatal:multiple Stage Entriesfor Merged File</title>
    <link href="http://www.devsai.com/2016/04/08/git-fail/"/>
    <id>http://www.devsai.com/2016/04/08/git-fail/</id>
    <published>2016-04-07T16:00:00.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>已经遇到过好几次这样的情况了</p><p>GIT报错：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fata<span class="variable">l:multiple</span> stage entries <span class="keyword">for</span> merged <span class="keyword">file</span></span><br></pre></td></tr></table></figure><p>在网上找下，也能很容易的找到对应的解决方案，方案如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm .git/index</span><br><span class="line">git <span class="keyword">add</span><span class="bash"> -A</span></span><br><span class="line"><span class="bash">git commit -m <span class="string">'fix git fatal error'</span></span></span><br></pre></td></tr></table></figure><p>但对于为什么会出现这样的错误，一直找不到个说法。希望知道原因的朋友能帮我解答疑惑。</p><blockquote><pre><code>自认为一个好的码农要知其然，更要知其所以然。</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;已经遇到过好几次这样的情况了&lt;/p&gt;
&lt;p&gt;GIT报错：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/
      
    
    </summary>
    
    
      <category term="git" scheme="http://www.devsai.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 Cross-Document Messaging(postMessage)</title>
    <link href="http://www.devsai.com/2016/02/17/postMessage/"/>
    <id>http://www.devsai.com/2016/02/17/postMessage/</id>
    <published>2016-02-16T16:00:00.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>window.postMessage是html5的新特性之一，<br>可以使用它来向其它的window对象发送消息，不管这个window对象是属于同源或不同源。</p><p>通过Cross-Document Messaging允许浏览器<strong>windows, tabs, and iFrames</strong>之间跨域通讯。</p><p>我们使用<code>postMessage()</code>方法去发送一条信息。</p><p><strong>postMessage发送信息</strong></p><p>postMessage需要接受两个参数</p><ul><li><strong>message</strong> 要发送的信息，可以是<code>string</code>也可以<code>object</code></li><li><strong>targetOrigin</strong> 接受信息的窗口的地址，这地址由接受窗口的protocol, port and hostname组成<br>也可以使用<code>*</code>来匹配任意的URL，但这会存在安全问题。</li></ul><p>这postMessage方法是被<strong>要接受信息的window所调用</strong>。</p><p>例如我们可以使用</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">new</span><span class="type">_wd</span> = window.open(<span class="string">'http://demos.devsai.com'</span>);</span><br></pre></td></tr></table></figure><p>打开一个新tab,<br>‘window.open’返回的就是新打开的<code>window</code>对象,<br>所以就可以这样来给新打开的window、tab窗口发送信息,</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span><span class="type">_wd</span>.postMessage(<span class="string">'hello demos'</span>,<span class="string">'http://demos.devsai.com/postmessage/receiver.html'</span>);</span><br></pre></td></tr></table></figure><p><strong>window接受信息</strong></p><p>如上述例子，可以在<code>http://demos.devsai.com/postmessage/receiver.html</code>中添加如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiverHandler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (e.origin !== <span class="string">"http://www.devsai.com"</span>)<span class="comment">//判断是哪个域过来的信息</span></span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">console</span>.log(e.data);<span class="comment">//接收到的信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,receiverHandler);</span><br></pre></td></tr></table></figure><p>接收的窗口除了使用<code>window.open</code>打开的以外，还可以是iframe窗口,我们可以通过以下代码获得iframe的window对象，<br>并对iframe发送信息.</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe_win = <span class="built_in">document</span>.getElementById(<span class="string">'recevier'</span>).contentWindow;</span><br><span class="line">iframe_win.postMessage(<span class="string">'hello iframe'</span>,<span class="string">'http://demos.devsai.com/postmessage/receiver.html'</span>);</span><br><span class="line"><span class="comment">##</span></span><br></pre></td></tr></table></figure><p><strong>浏览器的支持</strong><br>现在主流的浏览器都是支持<code>postMessage()</code>，也包括IE8+,但在IE8、IE9中还是有限制的，只能在docuemnt与iframe之间通讯才可使用<code>postMessage()</code>,想要在跨window或者tab之间通讯必须是IE10+.</p><table><thead><tr><th style="text-align:center">IE</th><th style="text-align:center">FIREFOX</th><th style="text-align:center">CHROME</th><th style="text-align:center">SAFARI</th><th style="text-align:center">OPERA</th></tr></thead><tbody><tr><td style="text-align:center">8+</td><td style="text-align:center">3.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">4.0+</td><td style="text-align:center">9.5+</td></tr></tbody></table><p>最后，<a href="/demo/postmessage/sender.html" target="_blank">想看DEMO,在这里穿越</a></p><p>DEMO也放在了github上，想要看code的同学，<a href="https://github.com/huangxiangsai/postMessage-demo" target="_blank">点击这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;window.postMessage是html5的新特性之一，&lt;br&gt;可以使用它来向其它的window对象发送消息，不管这个window对象是属于同源或不同源。&lt;/p&gt;
&lt;p&gt;通过Cross-Document Messaging允许浏览器&lt;strong&gt;windows, t
      
    
    </summary>
    
    
      <category term="HTML5" scheme="http://www.devsai.com/tags/HTML5/"/>
    
      <category term="postMessage" scheme="http://www.devsai.com/tags/postMessage/"/>
    
  </entry>
  
  <entry>
    <title>Bower下载依赖时git 超时问题</title>
    <link href="http://www.devsai.com/2015/09/03/bower%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96%E6%97%B6git%20%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://www.devsai.com/2015/09/03/bower下载依赖时git 超时问题/</id>
    <published>2015-09-03T08:36:59.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>##问题描述</p><p>执行命令：<code>bower install jquery-pjax</code></p><p>出现的错误信息：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bower <span class="builtin-name">error</span> status code of git: 128</span><br><span class="line">fatal: unable <span class="keyword">to</span> connect <span class="keyword">to</span> github.com:</span><br><span class="line">github.com[0: 你的IP]: <span class="attribute">errno</span>=Operation timed out</span><br></pre></td></tr></table></figure></p><p>其实这也不是bower下载依赖的问题， 而是git请求数据的问题 </p><p>这里以’bower下载依赖时git 超时问题’命题，主要还是因为是在使用<code>bower install</code>时出现的错.</p><p>这可以是需要用https才能读到数据<br>解决方法：输入命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global url.<span class="string">"https://"</span>.insteadOf git://</span><br></pre></td></tr></table></figure><p>##关于 bower </p><p>bower就是一个前端的依赖包管理器，就相当于java中流行的依赖管理工具MAVEN。</p><p>bower与npm很像，但又不同，我的理解是,bower主要服务于web项目前端依赖,而npm 则主要服务于nodejs.</p><p><a href="https://blog.openshift.com/day-1-bower-manage-your-client-side-dependencies/" target="_blank">openshift</a> 上一篇文章 对bower是什么，为什么使用它，怎么使用它等一些问题进行说明。</p>]]></content>
    
    <summary type="html">
    
      bower就是一个前端的依赖包管理器，就相当于java中流行的依赖管理工具MAVEN。bower与npm很像，但又不同，我的理解是,bower主要服务于web项目前端依赖,而npm 则主要服务于nodejs.
    
    </summary>
    
    
      <category term="前端" scheme="http://www.devsai.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Ssh连接时脚本自动执行</title>
    <link href="http://www.devsai.com/2015/08/10/ssh%E8%BF%9E%E6%8E%A5%E6%97%B6%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C/"/>
    <id>http://www.devsai.com/2015/08/10/ssh连接时脚本自动执行/</id>
    <published>2015-08-10T08:36:59.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>每次登陆远程服务器时，都会自动的执行当前用户下的.bash_profile文件。</p><p>只需要在里面写入你想要的脚本执行语句，就可以实现ssh连接时自动执行脚本的功能了.</p><p>示例如下:</p><p>登陆到服务器后 通过命令编写脚本 :<code>cd ~/ &amp;&amp; vim .bash_profile</code></p><p>添加红色区内容 :<br><img src="/images/2015/08/edit.jpg" alt="edit"></p><p>保存后， ssh退出重新连接。</p><p><img src="/images/2015/08/edited.jpg" alt=""></p><p>就能看到我们写的内容被执行了。</p><p>当然 你可以做些更有意义的、更复杂的事情.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每次登陆远程服务器时，都会自动的执行当前用户下的.bash_profile文件。&lt;/p&gt;
&lt;p&gt;只需要在里面写入你想要的脚本执行语句，就可以实现ssh连接时自动执行脚本的功能了.&lt;/p&gt;
&lt;p&gt;示例如下:&lt;/p&gt;
&lt;p&gt;登陆到服务器后 通过命令编写脚本 :&lt;code&gt;cd 
      
    
    </summary>
    
    
      <category term="ssh" scheme="http://www.devsai.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Liunx中获得文件的修改日期</title>
    <link href="http://www.devsai.com/2015/07/11/liunx%E4%B8%AD%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9%E6%97%A5%E6%9C%9F/"/>
    <id>http://www.devsai.com/2015/07/11/liunx中获得文件的修改日期/</id>
    <published>2015-07-11T08:36:59.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，我们需要知道某个文件有没有被修改过，以此做出相应的处理。</p><p>在liunx中， 就可以使用以下的脚本来实现 ：</p><pre><code>stat openapi.less | grep -i Modify | awk -F. &apos;{print $1}&apos; | awk &apos;{print $2$3}&apos;| awk -F- &apos;{print $1$2$3}&apos; | awk -F: &apos;{print $1$2$3}&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候，我们需要知道某个文件有没有被修改过，以此做出相应的处理。&lt;/p&gt;
&lt;p&gt;在liunx中， 就可以使用以下的脚本来实现 ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;stat openapi.less | grep -i Modify | awk -F. &amp;apos;{print
      
    
    </summary>
    
    
      <category term="liunx" scheme="http://www.devsai.com/tags/liunx/"/>
    
  </entry>
  
  <entry>
    <title>防淘宝注册验证滑动效果</title>
    <link href="http://www.devsai.com/2015/07/09/%E9%98%B2%E6%B7%98%E5%AE%9D%E6%B3%A8%E5%86%8C%E9%AA%8C%E8%AF%81%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C/"/>
    <id>http://www.devsai.com/2015/07/09/防淘宝注册验证滑动效果/</id>
    <published>2015-07-09T08:36:59.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>不多废话，直接看效果。</p><p></p><p data-height="268" data-theme-id="0" data-slug-hash="BNEPON" data-default-tab="result" data-user="huangxiangsai" class="codepen">See the Pen <a href="http://codepen.io/huangxiangsai/pen/BNEPON/" target="_blank" rel="noopener">BNEPON</a> by 黄向赛 (<a href="http://codepen.io/huangxiangsai" target="_blank" rel="noopener">@huangxiangsai</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="http://assets.codepen.io/assets/embed/ei.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不多废话，直接看效果。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p data-height=&quot;268&quot; data-theme-id=&quot;0&quot; data-slug-hash=&quot;BNEPON&quot; data-default-tab=&quot;result&quot; data-user=&quot;huangxiangsai&quot;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.devsai.com/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://www.devsai.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令汇总</title>
    <link href="http://www.devsai.com/2015/07/09/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <id>http://www.devsai.com/2015/07/09/git常用命令汇总/</id>
    <published>2015-07-09T08:36:59.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间由于工作需要，把项目从svn迁至了git上。</p><p>为此，公司的git高手做了一次分享。我们这些小白也从网上找资源，以便能尽快的入门。</p><p>在这过程中，队里伙伴找到了张图片，非常全的总结了git的常用命令。</p><p>虽然都不知道这图是谁分享的，但还是非常的感谢。</p><p><a href="/images/2015/08/2010072023345292.png" target="_blank">查看原图</a><br><img src="/images/2015/08/2010072023345292.png" alt=""></p><h3 id="实际用到的命令-持续更新中…"><a href="#实际用到的命令-持续更新中…" class="headerlink" title="实际用到的命令(持续更新中…)"></a>实际用到的命令(持续更新中…)</h3><p>下述内容或许上图中已提到，但为更方便的阅读与copy</p><h4 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a><strong>生成SSH key</strong></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh-keygen</span> <span class="selector-tag">-t</span> <span class="selector-tag">rsa</span> <span class="selector-tag">-C</span> "<span class="selector-tag">xxxx</span>@<span class="keyword">gmail</span>.<span class="keyword">com</span>"</span><br></pre></td></tr></table></figure><h4 id="检出历史版本到分支"><a href="#检出历史版本到分支" class="headerlink" title="检出历史版本到分支"></a><strong>检出历史版本到分支</strong></h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> checkout 分支号</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-<span class="keyword">b </span>[新分支名]</span><br></pre></td></tr></table></figure><h4 id="常用的自定义命令"><a href="#常用的自定义命令" class="headerlink" title="常用的自定义命令"></a><strong>常用的自定义命令</strong></h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方便查看当前的文件状态</span></span><br><span class="line">git<span class="built_in"> config </span>--global alias.s <span class="string">"status -s"</span> </span><br><span class="line"><span class="comment">#方便查看日志 人性化得显示时间，显示提交人</span></span><br><span class="line">git<span class="built_in"> config </span>--global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br></pre></td></tr></table></figure><h4 id="设置不忽略大小写"><a href="#设置不忽略大小写" class="headerlink" title="设置不忽略大小写"></a><strong>设置不忽略大小写</strong></h4><p>  <code>git config core.ignorecase false</code></p><h4 id="提交代码不用输入用户名密码"><a href="#提交代码不用输入用户名密码" class="headerlink" title="提交代码不用输入用户名密码"></a><strong>提交代码不用输入用户名密码</strong></h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解决方法 1</span></span><br><span class="line"><span class="comment">#通过ssh认证</span></span><br><span class="line"><span class="comment">#使用 git@... clone项目，之后的git操作都无需输入用户名、密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#解决方法 2</span></span><br><span class="line"><span class="comment">#可以不输密码 提交http地址的项目</span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">vim</span> ~/.git-credentials</span><br><span class="line"></span><br><span class="line">     https://[username]:[password]<span class="variable">@github</span>.com  <span class="comment">#github</span></span><br><span class="line">     http://[username]:[password]<span class="variable">@gitlab</span>.xxx.com  <span class="comment">#gitlab</span></span><br><span class="line"></span><br><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>两种方法结合可完全避免输密码提交</p><p>其实<code>.git-credentials</code>这个文件也可以不用自己来添加，<br>只需设置<code>git config --global credential.helper store</code><br>不自己手动添加的<code>.git-credentials</code>的影响就是，做git相关操作的时候需要输一遍用户名、密码。<br>然后git会自动生成<code>.git-credentials</code>文件并在文件中添加用户名密码</p><h4 id="撤销git-add操作"><a href="#撤销git-add操作" class="headerlink" title="撤销git add操作"></a><strong>撤销git add操作</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="keyword">HEAD</span>   (相当于把git <span class="keyword">add</span> . 操作的文件撤出暂存区)</span><br></pre></td></tr></table></figure><h4 id="远程库里已经存在这文件夹，但又想忽略此文件夹"><a href="#远程库里已经存在这文件夹，但又想忽略此文件夹" class="headerlink" title="远程库里已经存在这文件夹，但又想忽略此文件夹"></a><strong>远程库里已经存在这文件夹，但又想忽略此文件夹</strong></h4><p><img src="/images/gitignore.png" alt=""></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached filepath <span class="comment">#删除库里的文件记录</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br><span class="line"><span class="bash">git commit -m <span class="string">'fiexed gitIgnore '</span></span></span><br></pre></td></tr></table></figure><h4 id="合并多次的提交"><a href="#合并多次的提交" class="headerlink" title="合并多次的提交"></a><strong>合并多次的提交</strong></h4><p>有时我们会为修改一个BUG而提交多次，（修复一个BUG，提交后，由测试人员确认，发现还是有问题，然后继续做修复-提交的动作）<br>这时候就会感觉这多次的提交没有必要的，查看日志时也显得很凌乱。所以有必要对这些的提交进行合并提交的动作。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git rebase -<span class="selector-tag">i</span> HEAD^^  #合并近两次的提交</span><br><span class="line">#or</span><br><span class="line">git rebase -<span class="selector-tag">i</span> HEAD^^^ #合并近三次的提交</span><br><span class="line">#or</span><br><span class="line">git rebase -<span class="selector-tag">i</span> b3958ef #合并b3958ef之前的提交记录</span><br></pre></td></tr></table></figure><p>实例如下：</p><p><img src="/images/git-rebase-1.png" alt=""></p><p><img src="/images/git-rebase-2.png" alt=""></p><p><img src="/images/git-rebase-3.png" alt=""></p><p><img src="/images/git-rebase-4.png" alt=""></p><p><img src="/images/git-rebase-5.png" alt=""></p><p><img src="/images/git-rebase-6.png" alt=""></p><h4 id="上线版本，打tag加版本号"><a href="#上线版本，打tag加版本号" class="headerlink" title="上线版本，打tag加版本号"></a>上线版本，打tag加版本号</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建轻量标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag v0.1.2-light</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建附注标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v0.1.2 -m “0.1.2版本”</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用git show命令可以查看标签的版本信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show v0.1.2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v0.1.2 <span class="comment"># 删除标签</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v0.1.1 4fbc5d0  <span class="comment">#给指定的commit打标签 </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin v0.1.2 <span class="comment"># 将v0.1.2标签提交到git服务器</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前段时间由于工作需要，把项目从svn迁至了git上。
为此，公司的git高手做了一次分享。我们这些小白也从网上找资源，以便能尽快的入门。
在这过程中，队里伙伴找到了张图片，非常全的总结了git的常用命令。
虽然都不知道这图是谁分享的，但还是非常的感谢。
    
    </summary>
    
    
      <category term="git" scheme="http://www.devsai.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>jQuery.ajax在IE中跨域请求</title>
    <link href="http://www.devsai.com/2015/06/19/jQuery.ajax%E5%9C%A8IE%E4%B8%AD%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
    <id>http://www.devsai.com/2015/06/19/jQuery.ajax在IE中跨域请求/</id>
    <published>2015-06-19T08:36:59.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在小的项目中，估计永远都不会碰到跨域请求的问题。始终都是在一个域下面，可能连静态和动态都是在一起。</p><p>但是一个大项目，会将里面的业务拆分成多个子项目，根据业务的不同，子项目都会有它自己的子域。 所以在主项目中，访问不同业务下的接口，将会发生跨域的问题。</p><p>一般我们对于跨域会采用下以两种方式解决：</p><blockquote><ol><li><p>通过在返回的头部 <code>Access-Control-Allow-Origin</code> 添加指定的域，来允许跨域。</p></li><li><p>使用jsonp方式，实现跨域请求。</p></li></ol></blockquote><p>然而，很多时候，接口已经存在，并且已经在别处使用（不存在跨域问题），这时，一个在不同域的地方需要调用这个接口，我们第一想到的就是使用上述的第一种方式来解决跨域问题。</p><p>因为这样改动是最小的（程序猿都很懒的）</p><p>我也是一样，后端的童鞋改完后，我在chrome上调试下可以了。（我真的很厉害，虽然代码都不是我改的，只是刷了下页面）。</p><p>完了，在我们可爱的IE上也要试试的（我是IE9），不试不知道，一试吓一跳，通过fiddler居然没有找到请求。（IE真调皮）</p><p>没办法只有打开IE简陋的调试工具，在对应的<code>done</code>和<code>fail</code>中打印些信息出来。再次刷新页面后，果然进入的fail，并打印出了 <code>no transport</code> 。</p><p>这是什么错，没见过啊。于是就开始各种搜索， 搜索的结果，大致有两类，</p><p>一种是说，这跟IE的安全设置有关，要进入xxx &gt;&gt; xxx 然后再设置下就好了。</p><p>还有一种是说，直接换成<code>jsonp</code>吧。</p><p>第一种完全不靠谱，不可能让每个用户都这么干啊，pass ,第二种嘛，不多说了，还是再找找其他的方法吧。实在没办法才去想这么做。</p><p>最终，还在通过万能的google，找到了解决方法。 需要通过<code>jQuery.ajaxTransport</code>方法来设置一个对象，当然只需要在IE10以下的版本中使用就可以了。具体的代码如下：</p><pre><code>if (!jQuery.support.cors &amp;&amp; window.XDomainRequest) {            var httpRegEx = /^https?:\/\//i;            var getOrPostRegEx = /^get|post$/i;            var sameSchemeRegEx = new RegExp(&apos;^&apos;+location.protocol, &apos;i&apos;);            var xmlRegEx = /\/xml/i;            // ajaxTransport exists in jQuery 1.5+            jQuery.ajaxTransport(&apos;text html xml json&apos;, function(options, userOptions, jqXHR){                // XDomainRequests must be: asynchronous, GET or POST methods, HTTP or HTTPS protocol, and same scheme as calling page                if (options.crossDomain &amp;&amp; options.async &amp;&amp; getOrPostRegEx.test(options.type) &amp;&amp; httpRegEx.test(userOptions.url) &amp;&amp; sameSchemeRegEx.test(userOptions.url)) {                    var xdr = null;                    var userType = (userOptions.dataType||&apos;&apos;).toLowerCase();                    return {                        send: function(headers, complete){                            xdr = new XDomainRequest();                            if (/^\d+$/.test(userOptions.timeout)) {                                xdr.timeout = userOptions.timeout;                            }                            xdr.ontimeout = function(){                                complete(500, &apos;timeout&apos;);                            };                            xdr.onload = function(){                                var allResponseHeaders = &apos;Content-Length: &apos; + xdr.responseText.length + &apos;\r\nContent-Type: &apos; + xdr.contentType;                                var status = {                                    code: 200,                                    message: &apos;success&apos;                                };                                var responses = {                                    text: xdr.responseText                                };                                try {                                    if (userType === &apos;json&apos;) {                                        try {                                            responses.json = JSON.parse(xdr.responseText);                                        } catch(e) {                                            status.code = 500;                                            status.message = &apos;parseerror&apos;;                                            //throw &apos;Invalid JSON: &apos; + xdr.responseText;                                        }                                    } else if ((userType === &apos;xml&apos;) || ((userType !== &apos;text&apos;) &amp;&amp; xmlRegEx.test(xdr.contentType))) {                                        var doc = new ActiveXObject(&apos;Microsoft.XMLDOM&apos;);                                        doc.async = false;                                        try {                                            doc.loadXML(xdr.responseText);                                        } catch(e) {                                            doc = undefined;                                        }                                        if (!doc || !doc.documentElement || doc.getElementsByTagName(&apos;parsererror&apos;).length) {                                            status.code = 500;                                            status.message = &apos;parseerror&apos;;                                            throw &apos;Invalid XML: &apos; + xdr.responseText;                                        }                                        responses.xml = doc;                                    }                                } catch(parseMessage) {                                    throw parseMessage;                                } finally {                                    complete(status.code, status.message, responses, allResponseHeaders);                                }                            };                            xdr.onerror = function(){                                complete(500, &apos;error&apos;, {                                    text: xdr.responseText                                });                            };                            xdr.open(options.type, options.url);                            //xdr.send(userOptions.data);                            xdr.send();                        },                        abort: function(){                            if (xdr) {                                xdr.abort();                            }                        }                    };                }            });        };        jQuery.support.cors = true;        $.ajax({            crossDomain: true,            url : &apos;http://127.0.0.1:8080/fm/json&apos;,            type : &apos;GET&apos;,            dataType : &apos;json&apos;,        }).done(successHandler)        .fail(function() {            console.log(&apos;error&apos;);        });</code></pre><p>上面的代码看不是很清楚的话，有某个大神在JSFiddle中的demo,见花献佛了。<em><a href="http://jsfiddle.net/bjW8t/4/" target="_blank" rel="noopener">想看DEMO请猛击这里</a></em>。</p><p>再次刷IE，成功执行。 </p><p>随便再说下，在搜索这问题的时候，也有很多告诉说添加这一句<code>jQuery.support.cors = true;</code>就好了， 可添加了这句后，<code>no transport</code>的错是没了，但会报其他的错。然后就没然后了。</p><p>所以希望碰到这类问题的童鞋能看到这篇，也希望能对你有实质性的帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在小的项目中，估计永远都不会碰到跨域请求的问题。始终都是在一个域下面，可能连静态和动态都是在一起。&lt;/p&gt;
&lt;p&gt;但是一个大项目，会将里面的业务拆分成多个子项目，根据业务的不同，子项目都会有它自己的子域。 所以在主项目中，访问不同业务下的接口，将会发生跨域的问题。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.devsai.com/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://www.devsai.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Css之内容居中显示内容</title>
    <link href="http://www.devsai.com/2015/06/15/css%E4%B9%8B%E5%86%85%E5%AE%B9%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BA%E5%86%85%E5%AE%B9/"/>
    <id>http://www.devsai.com/2015/06/15/css之内容居中显示内容/</id>
    <published>2015-06-15T08:36:59.000Z</published>
    <updated>2017-09-23T02:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直知道想要居中显示元素  就需要如下样式</p><pre><code>margin:0 auto;</code></pre><p>但实际用起来 总不那么顺心，经常性的，有时有效果 ，有时又没效果了。</p><p>总结一句话，我的css弱爆了。 </p><p>为此请教了公司css专家 ，经过仔细的讲述后，学会了两种可居中的方法</p><ul><li><p>就像我前面提到的一样<code>margin:0 auto;</code>  确实可以居中 。</p><p>但是，是有条件的， 需要居中的元素必须是设定了宽了的，而且不能是百分比，否则就没看不出效果。</p></li><li><p>还有种方式就是<code>text-align:center;</code>  之前我一直以为这属性只能用作文本的居中，其实它也能作为元素的居中，</p><p>但也有个要注意的地方，居中的元素不能是块级元素，只能是行内元素。  </p><p>如果想让一个块级元素使用这种的居中方式，那么就必须让其变成行内元素。</p><p>可以通过设置CSS  <code>display</code>属性，设置为<code>inline</code> 或者<code>inline-block</code> 使元素变为行内元素。</p></li></ul><p>下面通过几个例子来看看上所述两种方法的效果:</p><p></p><p data-height="268" data-theme-id="0" data-slug-hash="gapQvr" data-default-tab="result" data-user="huangxiangsai" class="codepen">See the Pen <a href="http://codepen.io/huangxiangsai/pen/gapQvr/" target="_blank" rel="noopener">gapQvr</a> by 黄向赛 (<a href="http://codepen.io/huangxiangsai" target="_blank" rel="noopener">@huangxiangsai</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="http://assets.codepen.io/assets/embed/ei.js"></script><p>上面这个例子，就同时用到了两种元素居中方式。外层使用了margin的居中，里面层使用了text-align的方式居中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一直知道想要居中显示元素  就需要如下样式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;margin:0 auto;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但实际用起来 总不那么顺心，经常性的，有时有效果 ，有时又没效果了。&lt;/p&gt;
&lt;p&gt;总结一句话，我的css弱爆了。 &lt;/p&gt;
&lt;p&gt;为
      
    
    </summary>
    
    
      <category term="前端" scheme="http://www.devsai.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="css" scheme="http://www.devsai.com/tags/css/"/>
    
  </entry>
  
</feed>
